<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
  <fr:frontmatter>
    <fr:anchor>577</fr:anchor>
    <fr:addr type="user">andreaspavlogiannis</fr:addr>
    <fr:route>andreaspavlogiannis.xml</fr:route>
    <fr:title text="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:title>
    <fr:taxon>Person</fr:taxon>
    <fr:authors />
    <fr:meta name="external">https://pure.au.dk/portal/en/persons/pavlogiannis@cs.au.dk</fr:meta>
    <fr:meta name="institution">
      <fr:link type="local" href="aarhus.xml" addr="aarhus" title="Aarhus University">Aarhus University</fr:link>
    </fr:meta>
    <fr:meta name="orcid">0000-0002-8943-0722</fr:meta>
    <fr:meta name="position">Associate Professor</fr:meta>
  </fr:frontmatter>
  <fr:mainmatter>
    <fr:p>Associate Professor at Aarhus University.</fr:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:title text="Related">Related</fr:title>
        <fr:authors />
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>578</fr:anchor>
            <fr:addr type="user">aarhus</fr:addr>
            <fr:route>aarhus.xml</fr:route>
            <fr:title text="Aarhus University">Aarhus University</fr:title>
            <fr:taxon>Institution</fr:taxon>
            <fr:authors />
            <fr:meta name="external">https://international.au.dk/</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
          <fr:backmatter />
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter />
    </fr:tree>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:title text="Contributions">Contributions</fr:title>
        <fr:authors />
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>579</fr:anchor>
            <fr:addr type="user">zheng-mathur-pavlogiannis-osr-2024</fr:addr>
            <fr:route>zheng-mathur-pavlogiannis-osr-2024.xml</fr:route>
            <fr:title text="Optimistic Prediction of Synchronization-Reversal Data Races">Optimistic Prediction of Synchronization-Reversal Data Races</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>4</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="zhengshi.xml" addr="zhengshi" title="Zheng Shi">Zheng Shi</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{10.1145/3597503.3639099,
author = {Shi, Zheng and Mathur, Umang and Pavlogiannis, Andreas},
title = {Optimistic Prediction of Synchronization-Reversal Data Races},
year = {2024},
isbn = {9798400702174},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3597503.3639099},
doi = {10.1145/3597503.3639099},
abstract = {Dynamic data race detection has emerged as a key technique for ensuring reliability of concurrent software in practice. However, dynamic approaches can often miss data races owing to non-determinism in the thread scheduler. Predictive race detection techniques cater to this shortcoming by inferring alternate executions that may expose data races without re-executing the underlying program. More formally, the dynamic data race prediction problem asks, given a trace σ of an execution of a concurrent program, can σ be correctly reordered to expose a data race? Existing state-of-the art techniques for data race prediction either do not scale to executions arising from real world concurrent software, or only expose a limited class of data races, such as those that can be exposed without reversing the order of synchronization operations.In general, exposing data races by reasoning about synchronization reversals is an intractable problem. In this work, we identify a class of data races, called Optimistic Sync(hronization)-Reversal races that can be detected in a tractable manner and often include non-trivial data races that cannot be exposed by prior tractable techniques. We also propose a sound algorithm OSR for detecting all optimistic sync-reversal data races in overall quadratic time, and show that the algorithm is optimal by establishing a matching lower bound. Our experiments demonstrate the effectiveness of OSR--- on our extensive suite of benchmarks, OSR reports the largest number of data races, and scales well to large execution traces.},
booktitle = {Proceedings of the IEEE/ACM 46th International Conference on Software Engineering},
articleno = {134},
numpages = {13},
location = {Lisbon, Portugal},
series = {ICSE '24}
}]]></fr:meta>
            <fr:meta name="doi">10.1145/3597503.3639099</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>583</fr:anchor>
            <fr:addr type="user">mathur-pavlogiannis-tunç-viswanathan-treeclocks-2022</fr:addr>
            <fr:route>mathur-pavlogiannis-tunç-viswanathan-treeclocks-2022.xml</fr:route>
            <fr:title text="A tree clock data structure for causal orderings in concurrent executions">A tree clock data structure for causal orderings in concurrent executions</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>2</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="h%C3%BCnkarcantun%C3%A7.xml" addr="hünkarcantunç" title="Hünkar Can Tunç">Hünkar Can Tunç</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="maheshviswanathan.xml" addr="maheshviswanathan" title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{10.1145/3503222.3507734,
author = {Mathur, Umang and Pavlogiannis, Andreas and Tun\c{c}, H\"{u}nkar Can and Viswanathan, Mahesh},
title = {A tree clock data structure for causal orderings in concurrent executions},
year = {2022},
isbn = {9781450392051},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3503222.3507734},
doi = {10.1145/3503222.3507734},
abstract = {Dynamic techniques are a scalable and effective way to analyze concurrent programs. Instead of analyzing all behaviors of a program, these techniques detect errors by focusing on a single program execution. Often a crucial step in these techniques is to define a causal ordering between events in the execution, which is then computed using vector clocks, a simple data structure that stores logical times of threads. The two basic operations of vector clocks, namely join and copy, require Θ(k) time, where k is the number of threads. Thus they are a computational bottleneck when k is large. In this work, we introduce tree clocks, a new data structure that replaces vector clocks for computing causal orderings in program executions. Joining and copying tree clocks takes time that is roughly proportional to the number of entries being modified, and hence the two operations do not suffer the a-priori Θ(k) cost per application. We show that when used to compute the classic happens-before (HB) partial order, tree clocks are optimal, in the sense that no other data structure can lead to smaller asymptotic running time. Moreover, we demonstrate that tree clocks can be used to compute other partial orders, such as schedulable-happens-before (SHB) and the standard Mazurkiewicz (MAZ) partial order, and thus are a versatile data structure. Our experiments show that just by replacing vector clocks with tree clocks, the computation becomes from 2.02 \texttimes{} faster (MAZ) to 2.66 \texttimes{} (SHB) and 2.97 \texttimes{} (HB) on average per benchmark. These results illustrate that tree clocks have the potential to become a standard data structure with wide applications in concurrent analyses.},
booktitle = {Proceedings of the 27th ACM International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {710–725},
numpages = {16},
keywords = {concurrency, dynamic analyses, happens-before, vector clocks},
location = {Lausanne, Switzerland},
series = {ASPLOS '22}
}]]></fr:meta>
            <fr:meta name="doi">10.1145/3503222.3507734</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>588</fr:anchor>
            <fr:addr type="user">mathur-pavlogiannis-2021-asplos</fr:addr>
            <fr:route>mathur-pavlogiannis-2021-asplos.xml</fr:route>
            <fr:title text="Dynamic Data-Race Prediction : Fundamentals, Theory and Practice">Dynamic Data-Race Prediction : Fundamentals, Theory and Practice</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>4</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="external">https://www.youtube.com/watch?v=B6q2NQ5Tp2I</fr:meta>
            <fr:meta name="venue">ASPLOS 2021 Tutorial</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>Data races are arguably the most insidious amongst concurrency bugs and extensive research efforts have been dedicated to effectively detect them. Predictive race detection techniques aim to expose data races missed by traditional dynamic race detectors (such as those based on Happens-Before) by inferring data races in alternate executions of the underlying program, without re-executing it. The resulting promise of enhanced coverage in race detection has recently led to the development of many dynamic race prediction techniques.</fr:p>
            <fr:p>This tutorial aims to present the foundations of race prediction in a principled manner, consolidate a decade long line of work on dynamic race prediction and discusses recent algorithmic advances that make race prediction efficient and practical. This tutorial also aims to discuss some recent results on the complexity and hardness involved in reasoning about race prediction.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>591</fr:anchor>
            <fr:addr type="user">mathur-pavlogiannis-2021-popl</fr:addr>
            <fr:route>mathur-pavlogiannis-2021-popl.xml</fr:route>
            <fr:title text="Dynamic Data-Race Prediction: Fundamentals, Theory and Practice">Dynamic Data-Race Prediction: Fundamentals, Theory and Practice</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>1</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="external">https://www.youtube.com/watch?v=5AZIQFeluIY</fr:meta>
            <fr:meta name="venue">POPL 2021 Tutorial</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>Till date, concurrency bugs inevitably find their way into concurrent software despite rigorous development-time testing. Data races are arguably the most insidious amongst concurrency bugs and are particularly hard to detect.</fr:p>
            <fr:p>This tutorial focuses on recent developments in dynamic analysis techniques for detecting data races. Traditional dynamic race detection techniques, such as those based on Lamport’s happens-before (HB) partial order, are ineffective in exposing races that get ordered due to inexplicit synchronization, but can nevertheless be witnessed in alternate executions of the same underlying program. Predictive race detection techniques, on the other hand, aim to overcome this shortcoming of traditional dynamic race detectors by expose data races that can be missed by HB, without requiring a re-execution of the underlying program. The resulting promise of enhanced coverage in race detection has recently led to the development of many dynamic race prediction techniques.</fr:p>
            <fr:p>In this tutorial we will discuss some of the state-of-the-art algorithms and techniques for dynamic data race prediction, present the foundations of race prediction in a principled manner and discuss some recent investigations on the complexity and hardness involved in reasoning about race prediction.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>594</fr:anchor>
            <fr:addr type="user">mathur-pavlogiannis-viswanathan-syncp-2021</fr:addr>
            <fr:route>mathur-pavlogiannis-viswanathan-syncp-2021.xml</fr:route>
            <fr:title text="Optimal prediction of synchronization-preserving races">Optimal prediction of synchronization-preserving races</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>1</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="maheshviswanathan.xml" addr="maheshviswanathan" title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="bibtex"><![CDATA[@article{10.1145/3434317,
author = {Mathur, Umang and Pavlogiannis, Andreas and Viswanathan, Mahesh},
title = {Optimal prediction of synchronization-preserving races},
year = {2021},
issue_date = {January 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {POPL},
url = {https://doi.org/10.1145/3434317},
doi = {10.1145/3434317},
abstract = {Concurrent programs are notoriously hard to write correctly, as scheduling nondeterminism introduces subtle errors that are both hard to detect and to reproduce. The most common concurrency errors are (data) races, which occur when memory-conflicting actions are executed concurrently. Consequently, considerable effort has been made towards developing efficient techniques for race detection. The most common approach is dynamic race prediction: given an observed, race-free trace σ of a concurrent program, the task is to decide whether events of σ can be correctly reordered to a trace σ* that witnesses a race hidden in σ. In this work we introduce the notion of sync(hronization)-preserving races. A sync-preserving race occurs in σ when there is a witness σ* in which synchronization operations (e.g., acquisition and release of locks) appear in the same order as in σ. This is a broad definition that strictly subsumes the famous notion of happens-before races. Our main results are as follows. First, we develop a sound and complete algorithm for predicting sync-preserving races. For moderate values of parameters like the number of threads, the algorithm runs in \~{O}(N) time and space, where N is the length of the trace σ. Second, we show that the problem has a Ω(N/log2 N) space lower bound, and thus our algorithm is essentially time and space optimal. Third, we show that predicting races with even just a single reversal of two sync operations is NP-complete and even W1-hard when parameterized by the number of threads. Thus, sync-preservation characterizes exactly the tractability boundary of race prediction, and our algorithm is nearly optimal for the tractable side. Our experiments show that our algorithm is fast in practice, while sync-preservation characterizes races often missed by state-of-the-art methods.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {36},
numpages = {29},
keywords = {race detection, dynamic analysis, concurrency, complexity}
}]]></fr:meta>
            <fr:meta name="doi">10.1145/3434317</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>598</fr:anchor>
            <fr:addr type="user">mathur-pavlogiannis-viswanathan-2020</fr:addr>
            <fr:route>mathur-pavlogiannis-viswanathan-2020.xml</fr:route>
            <fr:title text="The Complexity of Dynamic Data Race Prediction">The Complexity of Dynamic Data Race Prediction</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2020</fr:year>
              <fr:month>7</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="maheshviswanathan.xml" addr="maheshviswanathan" title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{10.1145/3373718.3394783,
author = {Mathur, Umang and Pavlogiannis, Andreas and Viswanathan, Mahesh},
title = {The Complexity of Dynamic Data Race Prediction},
year = {2020},
isbn = {9781450371049},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3373718.3394783},
doi = {10.1145/3373718.3394783},
abstract = {Writing concurrent programs is notoriously hard due to scheduling non-determinism. The most common concurrency bugs are data races, which are accesses to a shared resource that can be executed concurrently. Dynamic data-race prediction is the most standard technique for detecting data races: given an observed, data-race-free trace t, the task is to determine whether t can be reordered to a trace t* that exposes a data-race. Although the problem has received significant practical attention for over three decades, its complexity has remained elusive. In this work, we address this lacuna, identifying sources of intractability and conditions under which the problem is efficiently solvable. Given a trace t of size n over k threads, our main results are as follows.First, we establish a general O(k · n2·(k-1) upper-bound, as well as an O(nk) upper-bound when certain parameters of t are constant. In addition, we show that the problem is NP-hard and even W[1]-hard parameterized by k, and thus unlikely to be fixed-parameter tractable. Second, we study the problem over acyclic communication topologies, such as server-clients hierarchies. We establish an O(k2 · d · n2 · log n) upper-bound, where d is the number of shared variables accessed in t. In addition, we show that even for traces with k = 2 threads, the problem has no O(n2-ϵ) algorithm under the Orthogonal Vectors conjecture. Since any trace with 2 threads defines an acyclic topology, our upper-bound for this case is optimal up to polynomial improvements for up to moderate values of k and d. Finally, motivated by existing heuristics, we study a distance-bounded version of the problem, where the task is to expose a data race by a witness trace that is similar to t. We develop an algorithm that works in O(n) time when certain parameters of t are constant.},
booktitle = {Proceedings of the 35th Annual ACM/IEEE Symposium on Logic in Computer Science},
pages = {713–727},
numpages = {15},
keywords = {Complexity, Data Race Prediction},
location = {Saarbr\"{u}cken, Germany},
series = {LICS '20}
}]]></fr:meta>
            <fr:meta name="doi">10.1145/3373718.3394783</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>602</fr:anchor>
            <fr:addr type="user">pavlogiannis-m2-2019</fr:addr>
            <fr:route>pavlogiannis-m2-2019.xml</fr:route>
            <fr:title text="Fast, sound, and effectively complete dynamic race prediction">Fast, sound, and effectively complete dynamic race prediction</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2019</fr:year>
              <fr:month>12</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="bibtex"><![CDATA[@article{10.1145/3371085,
author = {Pavlogiannis, Andreas},
title = {Fast, sound, and effectively complete dynamic race prediction},
year = {2019},
issue_date = {January 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {POPL},
url = {https://doi.org/10.1145/3371085},
doi = {10.1145/3371085},
abstract = {Writing concurrent programs is highly error-prone due to the nondeterminism in interprocess communication. The most reliable indicators of errors in concurrency are data races, which are accesses to a shared resource that can be executed concurrently. We study the problem of predicting data races in lock-based concurrent programs. The input consists of a concurrent trace t, and the task is to determine all pairs of events of t that constitute a data race. The problem lies at the heart of concurrent verification and has been extensively studied for over three decades. However, existing polynomial-time sound techniques are highly incomplete and can miss simple races. In this work we develop M2: a new polynomial-time algorithm for this problem, which has no false positives. In addition, our algorithm is complete for input traces that consist of two processes, i.e., it provably detects all races in the trace. We also develop sufficient criteria for detecting completeness dynamically in cases of more than two processes. We make an experimental evaluation of our algorithm on a challenging set of benchmarks taken from recent literature on the topic. Our algorithm soundly reports hundreds of real races, many of which are missed by existing methods. In addition, using our dynamic completeness criteria, M2 concludes that it has detected all races in the benchmark set, hence the reports are both sound and complete. Finally, its running times are comparable, and often smaller than the theoretically fastest, yet highly incomplete, existing methods. To our knowledge, M2 is the first sound algorithm that achieves such a level of performance on both running time and completeness of the reported races.},
journal = {Proc. ACM Program. Lang.},
month = {dec},
articleno = {17},
numpages = {29},
keywords = {race detection, predictive analyses, concurrency}
}]]></fr:meta>
            <fr:meta name="doi">10.1145/3371085</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
          <fr:backmatter />
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
