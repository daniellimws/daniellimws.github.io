<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
  <fr:frontmatter>
    <fr:anchor>715</fr:anchor>
    <fr:addr type="user">umangmathur</fr:addr>
    <fr:route>umangmathur.xml</fr:route>
    <fr:title text="Umang Mathur">Umang Mathur</fr:title>
    <fr:taxon>Person</fr:taxon>
    <fr:authors />
    <fr:meta name="external">https://www.comp.nus.edu.sg/~umathur/</fr:meta>
    <fr:meta name="institution">
      <fr:link type="local" href="nus.xml" addr="nus" title="National University of Singapore">National University of Singapore</fr:link>
    </fr:meta>
    <fr:meta name="orcid">0000-0002-7610-0660</fr:meta>
    <fr:meta name="position">Assistant Professor</fr:meta>
  </fr:frontmatter>
  <fr:mainmatter>
    <fr:p>Assistant Professor in Programming Languages &amp; Software Engineering at the National University of Singapore.</fr:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:title text="Related">Related</fr:title>
        <fr:authors />
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>716</fr:anchor>
            <fr:addr type="user">nus</fr:addr>
            <fr:route>nus.xml</fr:route>
            <fr:title text="National University of Singapore">National University of Singapore</fr:title>
            <fr:taxon>Institution</fr:taxon>
            <fr:authors />
            <fr:meta name="external">https://nus.edu.sg/</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
          <fr:backmatter />
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter />
    </fr:tree>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:title text="Contributions">Contributions</fr:title>
        <fr:authors />
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>717</fr:anchor>
            <fr:addr type="user">ang-mathur-prefix-2024</fr:addr>
            <fr:route>ang-mathur-prefix-2024.xml</fr:route>
            <fr:title text="Predictive Monitoring with Strong Trace Prefixes">Predictive Monitoring with Strong Trace Prefixes</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>7</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="zhendongang.xml" addr="zhendongang" title="Zhendong Ang">Zhendong Ang</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="bibtex"><![CDATA[@InProceedings{10.1007/978-3-031-65630-9_9,
author="Ang, Zhendong
and Mathur, Umang",
editor="Gurfinkel, Arie
and Ganesh, Vijay",
title="Predictive Monitoring with Strong Trace Prefixes",
booktitle="Computer Aided Verification",
year="2024",
publisher="Springer Nature Switzerland",
address="Cham",
pages="182--204",
abstract="Runtime predictive analyses enhance coverage of traditional dynamic analyses based bug detection techniques by identifying a space of feasible reorderings of the observed execution and determining if any reordering in this space witnesses the violation of some desired safety property. The most popular approach for modelling the space of feasible reorderings is through Mazurkiewicz's trace equivalence. The simplicity of the framework also gives rise to efficient predictive analyses, and has been the de facto means for obtaining space and time efficient algorithms for monitoring concurrent programs.",
isbn="978-3-031-65630-9"
}]]></fr:meta>
            <fr:meta name="doi">10.1007/978-3-031-65630-9_9</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>720</fr:anchor>
            <fr:addr type="user">zheng-mathur-pavlogiannis-osr-2024</fr:addr>
            <fr:route>zheng-mathur-pavlogiannis-osr-2024.xml</fr:route>
            <fr:title text="Optimistic Prediction of Synchronization-Reversal Data Races">Optimistic Prediction of Synchronization-Reversal Data Races</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>4</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="zhengshi.xml" addr="zhengshi" title="Zheng Shi">Zheng Shi</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{10.1145/3597503.3639099,
author = {Shi, Zheng and Mathur, Umang and Pavlogiannis, Andreas},
title = {Optimistic Prediction of Synchronization-Reversal Data Races},
year = {2024},
isbn = {9798400702174},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3597503.3639099},
doi = {10.1145/3597503.3639099},
abstract = {Dynamic data race detection has emerged as a key technique for ensuring reliability of concurrent software in practice. However, dynamic approaches can often miss data races owing to non-determinism in the thread scheduler. Predictive race detection techniques cater to this shortcoming by inferring alternate executions that may expose data races without re-executing the underlying program. More formally, the dynamic data race prediction problem asks, given a trace σ of an execution of a concurrent program, can σ be correctly reordered to expose a data race? Existing state-of-the art techniques for data race prediction either do not scale to executions arising from real world concurrent software, or only expose a limited class of data races, such as those that can be exposed without reversing the order of synchronization operations.In general, exposing data races by reasoning about synchronization reversals is an intractable problem. In this work, we identify a class of data races, called Optimistic Sync(hronization)-Reversal races that can be detected in a tractable manner and often include non-trivial data races that cannot be exposed by prior tractable techniques. We also propose a sound algorithm OSR for detecting all optimistic sync-reversal data races in overall quadratic time, and show that the algorithm is optimal by establishing a matching lower bound. Our experiments demonstrate the effectiveness of OSR--- on our extensive suite of benchmarks, OSR reports the largest number of data races, and scales well to large execution traces.},
booktitle = {Proceedings of the IEEE/ACM 46th International Conference on Software Engineering},
articleno = {134},
numpages = {13},
location = {Lisbon, Portugal},
series = {ICSE '24}
}]]></fr:meta>
            <fr:meta name="doi">10.1145/3597503.3639099</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>724</fr:anchor>
            <fr:addr type="user">farzan-mathur-grain-2024</fr:addr>
            <fr:route>farzan-mathur-grain-2024.xml</fr:route>
            <fr:title text="Coarser Equivalences for Causal Concurrency">Coarser Equivalences for Causal Concurrency</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>1</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="azadehfarzan.xml" addr="azadehfarzan" title="Azadeh Farzan">Azadeh Farzan</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="bibtex"><![CDATA[@article{10.1145/3632873,
author = {Farzan, Azadeh and Mathur, Umang},
title = {Coarser Equivalences for Causal Concurrency},
year = {2024},
issue_date = {January 2024},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {POPL},
url = {https://doi.org/10.1145/3632873},
doi = {10.1145/3632873},
abstract = {Trace theory (formulated by Mazurkiewicz in 1987) is a principled framework for defining equivalence relations for concurrent program runs based on a commutativity relation over the set of atomic steps taken by individual program threads. Its simplicity, elegance, and algorithmic efficiency makes it useful in many different contexts including program verification and testing. It is well-understood that the larger the equivalence classes are, the more benefits they would bring to the algorithms and applications that use them. In this paper, we study relaxations of trace equivalence with the goal of maintaining its algorithmic advantages. We first prove that the largest appropriate relaxation of trace equivalence, an equivalence relation that preserves the order of steps taken by each thread and what write operation each read operation observes, does not yield efficient algorithms. Specifically, we prove a linear space lower bound for the problem of checking, in a streaming setting, if two arbitrary steps of a concurrent program run are causally concurrent (i.e. they can be reordered in an equivalent run) or causally ordered (i.e. they always appear in the same order in all equivalent runs). The same problem can be decided in constant space for trace equivalence. Next, we propose a new commutativity-based notion of equivalence called grain equivalence that is strictly more relaxed than trace equivalence, and yet yields a constant space algorithm for the same problem. This notion of equivalence uses commutativity of grains, which are sequences of atomic steps, in addition to the standard commutativity from trace theory. We study the two distinct cases when the grains are contiguous subwords of the input program run and when they are not, formulate the precise definition of causal concurrency in each case, and show that they can be decided in constant space, despite being strict relaxations of the notion of causal concurrency based on trace equivalence.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {31},
numpages = {31},
keywords = {concurrency, equivalence, predictive analysis, reads-from, reduction}
}]]></fr:meta>
            <fr:meta name="doi">10.1145/3632873</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>727</fr:anchor>
            <fr:addr type="user">ang-mathur-pattern-2024</fr:addr>
            <fr:route>ang-mathur-pattern-2024.xml</fr:route>
            <fr:title text="Predictive Monitoring against Pattern Regular Languages">Predictive Monitoring against Pattern Regular Languages</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>1</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="zhendongang.xml" addr="zhendongang" title="Zhendong Ang">Zhendong Ang</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="bibtex"><![CDATA[@article{10.1145/3632915,
author = {Ang, Zhendong and Mathur, Umang},
title = {Predictive Monitoring against Pattern Regular Languages},
year = {2024},
issue_date = {January 2024},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {POPL},
url = {https://doi.org/10.1145/3632915},
doi = {10.1145/3632915},
abstract = {While current bug detection techniques for concurrent software focus on unearthing low-level issues such as data races or deadlocks, they often fall short of discovering more intricate temporal behaviours that can arise even in the absence of such low-level issues. In this paper, we focus on the problem of dynamically analysing concurrent software against high-level temporal specifications such as LTL. Existing techniques for runtime monitoring against such specifications are primarily designed for sequential software and remain inadequate in the presence of concurrency — violations may be observed only in intricate thread interleavings, requiring many re-runs of the underlying software in conjunction with the analysis. Towards this, we study the problem of predictive runtime monitoring, inspired by the analogous problem of predictive data race detection studied extensively recently. The predictive runtime monitoring question asks, given an execution σ, if it can be soundly reordered to expose violations of a specification. In general, this problem may become easily intractable when either the specifications or the notion of reorderings used is complex. In this paper, we focus on specifications that are given in regular languages. Our notion of reorderings is trace equivalence, where an execution is considered a reordering of another if it can be obtained from the latter by successively commuting adjacent independent actions. We first show that, even in this simplistic setting, the problem of predictive monitoring admits a super-linear lower bound of O(nα), where n is the number of events in the execution, and α is a parameter describing the degree of commutativity, and typically corresponds to the number of threads in the execution. As a result, predictive runtime monitoring even in this setting is unlikely to be efficiently solvable, unlike in the non-predictive setting where the problem can be checked using a deterministic finite automaton (and thus, a constant-space streaming linear-time algorithm). Towards this, we identify a sub-class of regular languages, called pattern languages (and their extension generalized pattern languages). Pattern languages can naturally express specific ordering of some number of (labelled) events, and have been inspired by popular empirical hypotheses underlying many concurrency bug detection approaches such as the “small bug depth” hypothesis. More importantly, we show that for pattern (and generalized pattern) languages, the predictive monitoring problem can be solved using a constant-space streaming linear-time algorithm. We implement and evaluate our algorithm PatternTrack on benchmarks from the literature and show that it is effective in monitoring large-scale applications.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {73},
numpages = {35},
keywords = {complexity, concurrency, dynamic analysis, predictive monitoring}
}]]></fr:meta>
            <fr:meta name="doi">10.1145/3632915</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>730</fr:anchor>
            <fr:addr type="user">thokair-zhang-mathur-viswanathan-rpt-2023</fr:addr>
            <fr:route>thokair-zhang-mathur-viswanathan-rpt-2023.xml</fr:route>
            <fr:title text="Dynamic Race Detection with O(1) Samples">Dynamic Race Detection with O(1) Samples</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>1</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="zhendongang.xml" addr="zhendongang" title="Zhendong Ang">Zhendong Ang</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="bibtex"><![CDATA[@article{10.1145/3571238,
author = {Thokair, Mosaad Al and Zhang, Minjian and Mathur, Umang and Viswanathan, Mahesh},
title = {Dynamic Race Detection with O(1) Samples},
year = {2023},
issue_date = {January 2023},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {7},
number = {POPL},
url = {https://doi.org/10.1145/3571238},
doi = {10.1145/3571238},
abstract = {Happens before-based dynamic analysis is the go-to technique for detecting data races in large scale software projects due to the absence of false positive reports. However, such analyses are expensive since they employ expensive vector clock updates at each event, rendering them usable only for in-house testing. In this paper, we present a sampling-based, randomized race detector that processes only constantly many events of the input trace even in the worst case. This is the first sub-linear time (i.e., running in o(n) time where n is the length of the trace) dynamic race detection algorithm; previous sampling based approaches like  run in linear time (i.e., O(n)). Our algorithm is a property tester for -race detection — it is sound in that it never reports any false positive, and on traces that are far, with respect to hamming distance, from any race-free trace, the algorithm detects an -race with high probability. Our experimental evaluation of the algorithm and its comparison with state-of-the-art deterministic and sampling based race detectors shows that the algorithm does indeed have significantly low running time, and detects races quite often.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {45},
numpages = {30},
keywords = {Concurrency - Shared memory, Dynamic program analysis, Happens-before race detection, Property testing}
}]]></fr:meta>
            <fr:meta name="doi">10.1145/3632915</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>733</fr:anchor>
            <fr:addr type="user">mathur-pavlogiannis-tunç-viswanathan-treeclocks-2022</fr:addr>
            <fr:route>mathur-pavlogiannis-tunç-viswanathan-treeclocks-2022.xml</fr:route>
            <fr:title text="A tree clock data structure for causal orderings in concurrent executions">A tree clock data structure for causal orderings in concurrent executions</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>2</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="h%C3%BCnkarcantun%C3%A7.xml" addr="hünkarcantunç" title="Hünkar Can Tunç">Hünkar Can Tunç</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="maheshviswanathan.xml" addr="maheshviswanathan" title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{10.1145/3503222.3507734,
author = {Mathur, Umang and Pavlogiannis, Andreas and Tun\c{c}, H\"{u}nkar Can and Viswanathan, Mahesh},
title = {A tree clock data structure for causal orderings in concurrent executions},
year = {2022},
isbn = {9781450392051},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3503222.3507734},
doi = {10.1145/3503222.3507734},
abstract = {Dynamic techniques are a scalable and effective way to analyze concurrent programs. Instead of analyzing all behaviors of a program, these techniques detect errors by focusing on a single program execution. Often a crucial step in these techniques is to define a causal ordering between events in the execution, which is then computed using vector clocks, a simple data structure that stores logical times of threads. The two basic operations of vector clocks, namely join and copy, require Θ(k) time, where k is the number of threads. Thus they are a computational bottleneck when k is large. In this work, we introduce tree clocks, a new data structure that replaces vector clocks for computing causal orderings in program executions. Joining and copying tree clocks takes time that is roughly proportional to the number of entries being modified, and hence the two operations do not suffer the a-priori Θ(k) cost per application. We show that when used to compute the classic happens-before (HB) partial order, tree clocks are optimal, in the sense that no other data structure can lead to smaller asymptotic running time. Moreover, we demonstrate that tree clocks can be used to compute other partial orders, such as schedulable-happens-before (SHB) and the standard Mazurkiewicz (MAZ) partial order, and thus are a versatile data structure. Our experiments show that just by replacing vector clocks with tree clocks, the computation becomes from 2.02 \texttimes{} faster (MAZ) to 2.66 \texttimes{} (SHB) and 2.97 \texttimes{} (HB) on average per benchmark. These results illustrate that tree clocks have the potential to become a standard data structure with wide applications in concurrent analyses.},
booktitle = {Proceedings of the 27th ACM International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {710–725},
numpages = {16},
keywords = {concurrency, dynamic analyses, happens-before, vector clocks},
location = {Lausanne, Switzerland},
series = {ASPLOS '22}
}]]></fr:meta>
            <fr:meta name="doi">10.1145/3503222.3507734</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>738</fr:anchor>
            <fr:addr type="user">mathur-pavlogiannis-2021-asplos</fr:addr>
            <fr:route>mathur-pavlogiannis-2021-asplos.xml</fr:route>
            <fr:title text="Dynamic Data-Race Prediction : Fundamentals, Theory and Practice">Dynamic Data-Race Prediction : Fundamentals, Theory and Practice</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>4</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="external">https://www.youtube.com/watch?v=B6q2NQ5Tp2I</fr:meta>
            <fr:meta name="venue">ASPLOS 2021 Tutorial</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>Data races are arguably the most insidious amongst concurrency bugs and extensive research efforts have been dedicated to effectively detect them. Predictive race detection techniques aim to expose data races missed by traditional dynamic race detectors (such as those based on Happens-Before) by inferring data races in alternate executions of the underlying program, without re-executing it. The resulting promise of enhanced coverage in race detection has recently led to the development of many dynamic race prediction techniques.</fr:p>
            <fr:p>This tutorial aims to present the foundations of race prediction in a principled manner, consolidate a decade long line of work on dynamic race prediction and discusses recent algorithmic advances that make race prediction efficient and practical. This tutorial also aims to discuss some recent results on the complexity and hardness involved in reasoning about race prediction.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>741</fr:anchor>
            <fr:addr type="user">mathur-pavlogiannis-2021-popl</fr:addr>
            <fr:route>mathur-pavlogiannis-2021-popl.xml</fr:route>
            <fr:title text="Dynamic Data-Race Prediction: Fundamentals, Theory and Practice">Dynamic Data-Race Prediction: Fundamentals, Theory and Practice</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>1</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="external">https://www.youtube.com/watch?v=5AZIQFeluIY</fr:meta>
            <fr:meta name="venue">POPL 2021 Tutorial</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>Till date, concurrency bugs inevitably find their way into concurrent software despite rigorous development-time testing. Data races are arguably the most insidious amongst concurrency bugs and are particularly hard to detect.</fr:p>
            <fr:p>This tutorial focuses on recent developments in dynamic analysis techniques for detecting data races. Traditional dynamic race detection techniques, such as those based on Lamport’s happens-before (HB) partial order, are ineffective in exposing races that get ordered due to inexplicit synchronization, but can nevertheless be witnessed in alternate executions of the same underlying program. Predictive race detection techniques, on the other hand, aim to overcome this shortcoming of traditional dynamic race detectors by expose data races that can be missed by HB, without requiring a re-execution of the underlying program. The resulting promise of enhanced coverage in race detection has recently led to the development of many dynamic race prediction techniques.</fr:p>
            <fr:p>In this tutorial we will discuss some of the state-of-the-art algorithms and techniques for dynamic data race prediction, present the foundations of race prediction in a principled manner and discuss some recent investigations on the complexity and hardness involved in reasoning about race prediction.</fr:p>
          </fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>744</fr:anchor>
            <fr:addr type="user">mathur-pavlogiannis-viswanathan-syncp-2021</fr:addr>
            <fr:route>mathur-pavlogiannis-viswanathan-syncp-2021.xml</fr:route>
            <fr:title text="Optimal prediction of synchronization-preserving races">Optimal prediction of synchronization-preserving races</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>1</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="maheshviswanathan.xml" addr="maheshviswanathan" title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="bibtex"><![CDATA[@article{10.1145/3434317,
author = {Mathur, Umang and Pavlogiannis, Andreas and Viswanathan, Mahesh},
title = {Optimal prediction of synchronization-preserving races},
year = {2021},
issue_date = {January 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {POPL},
url = {https://doi.org/10.1145/3434317},
doi = {10.1145/3434317},
abstract = {Concurrent programs are notoriously hard to write correctly, as scheduling nondeterminism introduces subtle errors that are both hard to detect and to reproduce. The most common concurrency errors are (data) races, which occur when memory-conflicting actions are executed concurrently. Consequently, considerable effort has been made towards developing efficient techniques for race detection. The most common approach is dynamic race prediction: given an observed, race-free trace σ of a concurrent program, the task is to decide whether events of σ can be correctly reordered to a trace σ* that witnesses a race hidden in σ. In this work we introduce the notion of sync(hronization)-preserving races. A sync-preserving race occurs in σ when there is a witness σ* in which synchronization operations (e.g., acquisition and release of locks) appear in the same order as in σ. This is a broad definition that strictly subsumes the famous notion of happens-before races. Our main results are as follows. First, we develop a sound and complete algorithm for predicting sync-preserving races. For moderate values of parameters like the number of threads, the algorithm runs in \~{O}(N) time and space, where N is the length of the trace σ. Second, we show that the problem has a Ω(N/log2 N) space lower bound, and thus our algorithm is essentially time and space optimal. Third, we show that predicting races with even just a single reversal of two sync operations is NP-complete and even W1-hard when parameterized by the number of threads. Thus, sync-preservation characterizes exactly the tractability boundary of race prediction, and our algorithm is nearly optimal for the tractable side. Our experiments show that our algorithm is fast in practice, while sync-preservation characterizes races often missed by state-of-the-art methods.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {36},
numpages = {29},
keywords = {race detection, dynamic analysis, concurrency, complexity}
}]]></fr:meta>
            <fr:meta name="doi">10.1145/3434317</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>748</fr:anchor>
            <fr:addr type="user">mathur-pavlogiannis-viswanathan-2020</fr:addr>
            <fr:route>mathur-pavlogiannis-viswanathan-2020.xml</fr:route>
            <fr:title text="The Complexity of Dynamic Data Race Prediction">The Complexity of Dynamic Data Race Prediction</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2020</fr:year>
              <fr:month>7</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="maheshviswanathan.xml" addr="maheshviswanathan" title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{10.1145/3373718.3394783,
author = {Mathur, Umang and Pavlogiannis, Andreas and Viswanathan, Mahesh},
title = {The Complexity of Dynamic Data Race Prediction},
year = {2020},
isbn = {9781450371049},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3373718.3394783},
doi = {10.1145/3373718.3394783},
abstract = {Writing concurrent programs is notoriously hard due to scheduling non-determinism. The most common concurrency bugs are data races, which are accesses to a shared resource that can be executed concurrently. Dynamic data-race prediction is the most standard technique for detecting data races: given an observed, data-race-free trace t, the task is to determine whether t can be reordered to a trace t* that exposes a data-race. Although the problem has received significant practical attention for over three decades, its complexity has remained elusive. In this work, we address this lacuna, identifying sources of intractability and conditions under which the problem is efficiently solvable. Given a trace t of size n over k threads, our main results are as follows.First, we establish a general O(k · n2·(k-1) upper-bound, as well as an O(nk) upper-bound when certain parameters of t are constant. In addition, we show that the problem is NP-hard and even W[1]-hard parameterized by k, and thus unlikely to be fixed-parameter tractable. Second, we study the problem over acyclic communication topologies, such as server-clients hierarchies. We establish an O(k2 · d · n2 · log n) upper-bound, where d is the number of shared variables accessed in t. In addition, we show that even for traces with k = 2 threads, the problem has no O(n2-ϵ) algorithm under the Orthogonal Vectors conjecture. Since any trace with 2 threads defines an acyclic topology, our upper-bound for this case is optimal up to polynomial improvements for up to moderate values of k and d. Finally, motivated by existing heuristics, we study a distance-bounded version of the problem, where the task is to expose a data race by a witness trace that is similar to t. We develop an algorithm that works in O(n) time when certain parameters of t are constant.},
booktitle = {Proceedings of the 35th Annual ACM/IEEE Symposium on Logic in Computer Science},
pages = {713–727},
numpages = {15},
keywords = {Complexity, Data Race Prediction},
location = {Saarbr\"{u}cken, Germany},
series = {LICS '20}
}]]></fr:meta>
            <fr:meta name="doi">10.1145/3373718.3394783</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>752</fr:anchor>
            <fr:addr type="user">mathur-kini-viswanathan-shb-2018</fr:addr>
            <fr:route>mathur-kini-viswanathan-shb-2018.xml</fr:route>
            <fr:title text="What happens-after the first race? Enhancing the predictive power of happens-before based dynamic race detection">What happens-after the first race? Enhancing the predictive power of happens-before based dynamic race detection</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2018</fr:year>
              <fr:month>10</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
              </fr:author>
              <fr:author>Dileep Kini</fr:author>
              <fr:author>
                <fr:link type="local" href="maheshviswanathan.xml" addr="maheshviswanathan" title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="bibtex"><![CDATA[@article{10.1145/3276515,
author = {Mathur, Umang and Kini, Dileep and Viswanathan, Mahesh},
title = {What happens-after the first race? enhancing the predictive power of happens-before based dynamic race detection},
year = {2018},
issue_date = {November 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {OOPSLA},
url = {https://doi.org/10.1145/3276515},
doi = {10.1145/3276515},
abstract = {Dynamic race detection is the problem of determining if an observed program execution reveals the presence of a data race in a program. The classical approach to solving this problem is to detect if there is a pair of conflicting memory accesses that are unordered by Lamport’s happens-before (HB) relation. HB based race detection is known to not report false positives, i.e., it is sound. However, the soundness guarantee of HB only promises that the first pair of unordered, conflicting events is a schedulable data race. That is, there can be pairs of HB-unordered conflicting data accesses that are not schedulable races because there is no reordering of the events of the execution, where the events in race can be executed immediately after each other. We introduce a new partial order, called schedulable happens-before (SHB) that exactly characterizes the pairs of schedulable data races — every pair of conflicting data accesses that are identified by SHB can be scheduled, and every HB-race that can be scheduled is identified by SHB. Thus, the SHB partial order is truly sound. We present a linear time, vector clock algorithm to detect schedulable races using SHB. Our experiments demonstrate the value of our algorithm for dynamic race detection — SHB incurs only little performance overhead and can scale to executions from real-world software applications without compromising soundness.},
journal = {Proc. ACM Program. Lang.},
month = {oct},
articleno = {145},
numpages = {29},
keywords = {Concurrency, Dynamic Program Analysis, Happens-Before, Race Detection, Soundness}
}]]></fr:meta>
            <fr:meta name="doi">10.1145/3276515</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>756</fr:anchor>
            <fr:addr type="user">kini-mathur-viswanathan-wcp-2017</fr:addr>
            <fr:route>kini-mathur-viswanathan-wcp-2017.xml</fr:route>
            <fr:title text="Dynamic race prediction in linear time">Dynamic race prediction in linear time</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2017</fr:year>
              <fr:month>6</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>Dileep Kini</fr:author>
              <fr:author>
                <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="maheshviswanathan.xml" addr="maheshviswanathan" title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{10.1145/3062341.3062374,
author = {Kini, Dileep and Mathur, Umang and Viswanathan, Mahesh},
title = {Dynamic race prediction in linear time},
year = {2017},
isbn = {9781450349888},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3062341.3062374},
doi = {10.1145/3062341.3062374},
abstract = {Writing reliable concurrent software remains a huge challenge for today's programmers. Programmers rarely reason about their code by explicitly considering different possible inter-leavings of its execution. We consider the problem of detecting data races from individual executions in a sound manner. The classical approach to solving this problem has been to use Lamport's happens-before (HB) relation. Until now HB remains the only approach that runs in linear time. Previous efforts in improving over HB such as causally-precedes (CP) and maximal causal models fall short due to the fact that they are not implementable efficiently and hence have to compromise on their race detecting ability by limiting their techniques to bounded sized fragments of the execution. We present a new relation weak-causally-precedes (WCP) that is provably better than CP in terms of being able to detect more races, while still remaining sound. Moreover, it admits a linear time algorithm which works on the entire execution without having to fragment it.},
booktitle = {Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {157–170},
numpages = {14},
keywords = {Race Prediction, Online Algorithm, Concurrency},
location = {Barcelona, Spain},
series = {PLDI 2017}
}

@article{10.1145/3140587.3062374,
author = {Kini, Dileep and Mathur, Umang and Viswanathan, Mahesh},
title = {Dynamic race prediction in linear time},
year = {2017},
issue_date = {June 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/3140587.3062374},
doi = {10.1145/3140587.3062374},
abstract = {Writing reliable concurrent software remains a huge challenge for today's programmers. Programmers rarely reason about their code by explicitly considering different possible inter-leavings of its execution. We consider the problem of detecting data races from individual executions in a sound manner. The classical approach to solving this problem has been to use Lamport's happens-before (HB) relation. Until now HB remains the only approach that runs in linear time. Previous efforts in improving over HB such as causally-precedes (CP) and maximal causal models fall short due to the fact that they are not implementable efficiently and hence have to compromise on their race detecting ability by limiting their techniques to bounded sized fragments of the execution. We present a new relation weak-causally-precedes (WCP) that is provably better than CP in terms of being able to detect more races, while still remaining sound. Moreover, it admits a linear time algorithm which works on the entire execution without having to fragment it.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {157–170},
numpages = {14},
keywords = {Race Prediction, Online Algorithm, Concurrency}
}]]></fr:meta>
            <fr:meta name="doi">10.1145/3062341.3062374</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
          <fr:backmatter />
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
