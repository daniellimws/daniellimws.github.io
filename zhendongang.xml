<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>713</fr:anchor><fr:addr
type="user">zhendongang</fr:addr><fr:route>zhendongang.xml</fr:route><fr:title
text="Zhendong Ang">Zhendong Ang</fr:title><fr:taxon>Person</fr:taxon><fr:authors /><fr:meta
name="external">https://ang9876.github.io/</fr:meta><fr:meta
name="institution"><fr:link
type="local"
href="nus.xml"
addr="nus"
title="National University of Singapore">National University of Singapore</fr:link></fr:meta><fr:meta
name="orcid">0009-0002-0214-3462</fr:meta><fr:meta
name="position">PhD</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>PhD student in Programming Languages &amp; Software Engineering at the National University of Singapore.</fr:p></fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Related">Related</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>714</fr:anchor><fr:addr
type="user">nus</fr:addr><fr:route>nus.xml</fr:route><fr:title
text="National University of Singapore">National University of Singapore</fr:title><fr:taxon>Institution</fr:taxon><fr:authors /><fr:meta
name="external">https://nus.edu.sg/</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Contributions">Contributions</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>715</fr:anchor><fr:addr
type="user">ang-mathur-prefix-2024</fr:addr><fr:route>ang-mathur-prefix-2024.xml</fr:route><fr:title
text="Predictive Monitoring with Strong Trace Prefixes">Predictive Monitoring with Strong Trace Prefixes</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month></fr:date><fr:authors><fr:author><fr:link
type="local"
href="zhendongang.xml"
addr="zhendongang"
title="Zhendong Ang">Zhendong Ang</fr:link></fr:author><fr:author><fr:link
type="local"
href="umangmathur.xml"
addr="umangmathur"
title="Umang Mathur">Umang Mathur</fr:link></fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@InProceedings{10.1007/978-3-031-65630-9_9,
author="Ang, Zhendong
and Mathur, Umang",
editor="Gurfinkel, Arie
and Ganesh, Vijay",
title="Predictive Monitoring with Strong Trace Prefixes",
booktitle="Computer Aided Verification",
year="2024",
publisher="Springer Nature Switzerland",
address="Cham",
pages="182--204",
abstract="Runtime predictive analyses enhance coverage of traditional dynamic analyses based bug detection techniques by identifying a space of feasible reorderings of the observed execution and determining if any reordering in this space witnesses the violation of some desired safety property. The most popular approach for modelling the space of feasible reorderings is through Mazurkiewicz's trace equivalence. The simplicity of the framework also gives rise to efficient predictive analyses, and has been the de facto means for obtaining space and time efficient algorithms for monitoring concurrent programs.",
isbn="978-3-031-65630-9"
}]]></fr:meta><fr:meta
name="doi">10.1007/978-3-031-65630-9_9</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>718</fr:anchor><fr:addr
type="user">ang-mathur-pattern-2024</fr:addr><fr:route>ang-mathur-pattern-2024.xml</fr:route><fr:title
text="Predictive Monitoring against Pattern Regular Languages">Predictive Monitoring against Pattern Regular Languages</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month></fr:date><fr:authors><fr:author><fr:link
type="local"
href="zhendongang.xml"
addr="zhendongang"
title="Zhendong Ang">Zhendong Ang</fr:link></fr:author><fr:author><fr:link
type="local"
href="umangmathur.xml"
addr="umangmathur"
title="Umang Mathur">Umang Mathur</fr:link></fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@article{10.1145/3632915,
author = {Ang, Zhendong and Mathur, Umang},
title = {Predictive Monitoring against Pattern Regular Languages},
year = {2024},
issue_date = {January 2024},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {POPL},
url = {https://doi.org/10.1145/3632915},
doi = {10.1145/3632915},
abstract = {While current bug detection techniques for concurrent software focus on unearthing low-level issues such as data races or deadlocks, they often fall short of discovering more intricate temporal behaviours that can arise even in the absence of such low-level issues. In this paper, we focus on the problem of dynamically analysing concurrent software against high-level temporal specifications such as LTL. Existing techniques for runtime monitoring against such specifications are primarily designed for sequential software and remain inadequate in the presence of concurrency — violations may be observed only in intricate thread interleavings, requiring many re-runs of the underlying software in conjunction with the analysis. Towards this, we study the problem of predictive runtime monitoring, inspired by the analogous problem of predictive data race detection studied extensively recently. The predictive runtime monitoring question asks, given an execution σ, if it can be soundly reordered to expose violations of a specification. In general, this problem may become easily intractable when either the specifications or the notion of reorderings used is complex. In this paper, we focus on specifications that are given in regular languages. Our notion of reorderings is trace equivalence, where an execution is considered a reordering of another if it can be obtained from the latter by successively commuting adjacent independent actions. We first show that, even in this simplistic setting, the problem of predictive monitoring admits a super-linear lower bound of O(nα), where n is the number of events in the execution, and α is a parameter describing the degree of commutativity, and typically corresponds to the number of threads in the execution. As a result, predictive runtime monitoring even in this setting is unlikely to be efficiently solvable, unlike in the non-predictive setting where the problem can be checked using a deterministic finite automaton (and thus, a constant-space streaming linear-time algorithm). Towards this, we identify a sub-class of regular languages, called pattern languages (and their extension generalized pattern languages). Pattern languages can naturally express specific ordering of some number of (labelled) events, and have been inspired by popular empirical hypotheses underlying many concurrency bug detection approaches such as the “small bug depth” hypothesis. More importantly, we show that for pattern (and generalized pattern) languages, the predictive monitoring problem can be solved using a constant-space streaming linear-time algorithm. We implement and evaluate our algorithm PatternTrack on benchmarks from the literature and show that it is effective in monitoring large-scale applications.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {73},
numpages = {35},
keywords = {complexity, concurrency, dynamic analysis, predictive monitoring}
}]]></fr:meta><fr:meta
name="doi">10.1145/3632915</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>721</fr:anchor><fr:addr
type="user">thokair-zhang-mathur-viswanathan-rpt-2023</fr:addr><fr:route>thokair-zhang-mathur-viswanathan-rpt-2023.xml</fr:route><fr:title
text="Dynamic Race Detection with O(1) Samples">Dynamic Race Detection with O(1) Samples</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2023</fr:year><fr:month>1</fr:month></fr:date><fr:authors><fr:author><fr:link
type="local"
href="zhendongang.xml"
addr="zhendongang"
title="Zhendong Ang">Zhendong Ang</fr:link></fr:author><fr:author><fr:link
type="local"
href="umangmathur.xml"
addr="umangmathur"
title="Umang Mathur">Umang Mathur</fr:link></fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@article{10.1145/3571238,
author = {Thokair, Mosaad Al and Zhang, Minjian and Mathur, Umang and Viswanathan, Mahesh},
title = {Dynamic Race Detection with O(1) Samples},
year = {2023},
issue_date = {January 2023},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {7},
number = {POPL},
url = {https://doi.org/10.1145/3571238},
doi = {10.1145/3571238},
abstract = {Happens before-based dynamic analysis is the go-to technique for detecting data races in large scale software projects due to the absence of false positive reports. However, such analyses are expensive since they employ expensive vector clock updates at each event, rendering them usable only for in-house testing. In this paper, we present a sampling-based, randomized race detector that processes only constantly many events of the input trace even in the worst case. This is the first sub-linear time (i.e., running in o(n) time where n is the length of the trace) dynamic race detection algorithm; previous sampling based approaches like  run in linear time (i.e., O(n)). Our algorithm is a property tester for -race detection — it is sound in that it never reports any false positive, and on traces that are far, with respect to hamming distance, from any race-free trace, the algorithm detects an -race with high probability. Our experimental evaluation of the algorithm and its comparison with state-of-the-art deterministic and sampling based race detectors shows that the algorithm does indeed have significantly low running time, and detects races quite often.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {45},
numpages = {30},
keywords = {Concurrency - Shared memory, Dynamic program analysis, Happens-before race detection, Property testing}
}]]></fr:meta><fr:meta
name="doi">10.1145/3632915</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>