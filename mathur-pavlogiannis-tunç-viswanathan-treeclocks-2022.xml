<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
  <fr:frontmatter>
    <fr:anchor>554</fr:anchor>
    <fr:addr type="user">mathur-pavlogiannis-tunç-viswanathan-treeclocks-2022</fr:addr>
    <fr:route>mathur-pavlogiannis-tunç-viswanathan-treeclocks-2022.xml</fr:route>
    <fr:title text="A tree clock data structure for causal orderings in concurrent executions">A tree clock data structure for causal orderings in concurrent executions</fr:title>
    <fr:taxon>Reference</fr:taxon>
    <fr:date>
      <fr:year>2022</fr:year>
      <fr:month>2</fr:month>
    </fr:date>
    <fr:authors>
      <fr:author>
        <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
      </fr:author>
      <fr:author>
        <fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link>
      </fr:author>
      <fr:author>
        <fr:link type="local" href="h%C3%BCnkarcantun%C3%A7.xml" addr="hünkarcantunç" title="Hünkar Can Tunç">Hünkar Can Tunç</fr:link>
      </fr:author>
      <fr:author>
        <fr:link type="local" href="maheshviswanathan.xml" addr="maheshviswanathan" title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link>
      </fr:author>
    </fr:authors>
    <fr:meta name="bibtex"><![CDATA[@inproceedings{10.1145/3503222.3507734,
author = {Mathur, Umang and Pavlogiannis, Andreas and Tun\c{c}, H\"{u}nkar Can and Viswanathan, Mahesh},
title = {A tree clock data structure for causal orderings in concurrent executions},
year = {2022},
isbn = {9781450392051},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3503222.3507734},
doi = {10.1145/3503222.3507734},
abstract = {Dynamic techniques are a scalable and effective way to analyze concurrent programs. Instead of analyzing all behaviors of a program, these techniques detect errors by focusing on a single program execution. Often a crucial step in these techniques is to define a causal ordering between events in the execution, which is then computed using vector clocks, a simple data structure that stores logical times of threads. The two basic operations of vector clocks, namely join and copy, require Θ(k) time, where k is the number of threads. Thus they are a computational bottleneck when k is large. In this work, we introduce tree clocks, a new data structure that replaces vector clocks for computing causal orderings in program executions. Joining and copying tree clocks takes time that is roughly proportional to the number of entries being modified, and hence the two operations do not suffer the a-priori Θ(k) cost per application. We show that when used to compute the classic happens-before (HB) partial order, tree clocks are optimal, in the sense that no other data structure can lead to smaller asymptotic running time. Moreover, we demonstrate that tree clocks can be used to compute other partial orders, such as schedulable-happens-before (SHB) and the standard Mazurkiewicz (MAZ) partial order, and thus are a versatile data structure. Our experiments show that just by replacing vector clocks with tree clocks, the computation becomes from 2.02 \texttimes{} faster (MAZ) to 2.66 \texttimes{} (SHB) and 2.97 \texttimes{} (HB) on average per benchmark. These results illustrate that tree clocks have the potential to become a standard data structure with wide applications in concurrent analyses.},
booktitle = {Proceedings of the 27th ACM International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {710–725},
numpages = {16},
keywords = {concurrency, dynamic analyses, happens-before, vector clocks},
location = {Lausanne, Switzerland},
series = {ASPLOS '22}
}]]></fr:meta>
    <fr:meta name="doi">10.1145/3503222.3507734</fr:meta>
  </fr:frontmatter>
  <fr:mainmatter />
  <fr:backmatter />
</fr:tree>
