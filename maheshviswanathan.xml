<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
  <fr:frontmatter>
    <fr:anchor>674</fr:anchor>
    <fr:addr type="user">maheshviswanathan</fr:addr>
    <fr:route>maheshviswanathan.xml</fr:route>
    <fr:title text="Mahesh Viswanathan">Mahesh Viswanathan</fr:title>
    <fr:taxon>Person</fr:taxon>
    <fr:authors />
    <fr:meta name="external">https://vmahesh.cs.illinois.edu/</fr:meta>
    <fr:meta name="institution">
      <fr:link type="local" href="uiuc.xml" addr="uiuc" title="University of Illinois at Urbana-Champaign, USA">University of Illinois at Urbana-Champaign, USA</fr:link>
    </fr:meta>
  </fr:frontmatter>
  <fr:mainmatter />
  <fr:backmatter>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:title text="Related">Related</fr:title>
        <fr:authors />
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>675</fr:anchor>
            <fr:addr type="user">uiuc</fr:addr>
            <fr:route>uiuc.xml</fr:route>
            <fr:title text="University of Illinois at Urbana-Champaign, USA">University of Illinois at Urbana-Champaign, USA</fr:title>
            <fr:taxon>Institution</fr:taxon>
            <fr:authors />
            <fr:meta name="external">https://illinois.edu/</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
          <fr:backmatter />
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter />
    </fr:tree>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:title text="Contributions">Contributions</fr:title>
        <fr:authors />
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>676</fr:anchor>
            <fr:addr type="user">mathur-pavlogiannis-tunç-viswanathan-treeclocks-2022</fr:addr>
            <fr:route>mathur-pavlogiannis-tunç-viswanathan-treeclocks-2022.xml</fr:route>
            <fr:title text="A tree clock data structure for causal orderings in concurrent executions">A tree clock data structure for causal orderings in concurrent executions</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>2</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="h%C3%BCnkarcantun%C3%A7.xml" addr="hünkarcantunç" title="Hünkar Can Tunç">Hünkar Can Tunç</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="maheshviswanathan.xml" addr="maheshviswanathan" title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{10.1145/3503222.3507734,
author = {Mathur, Umang and Pavlogiannis, Andreas and Tun\c{c}, H\"{u}nkar Can and Viswanathan, Mahesh},
title = {A tree clock data structure for causal orderings in concurrent executions},
year = {2022},
isbn = {9781450392051},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3503222.3507734},
doi = {10.1145/3503222.3507734},
abstract = {Dynamic techniques are a scalable and effective way to analyze concurrent programs. Instead of analyzing all behaviors of a program, these techniques detect errors by focusing on a single program execution. Often a crucial step in these techniques is to define a causal ordering between events in the execution, which is then computed using vector clocks, a simple data structure that stores logical times of threads. The two basic operations of vector clocks, namely join and copy, require Θ(k) time, where k is the number of threads. Thus they are a computational bottleneck when k is large. In this work, we introduce tree clocks, a new data structure that replaces vector clocks for computing causal orderings in program executions. Joining and copying tree clocks takes time that is roughly proportional to the number of entries being modified, and hence the two operations do not suffer the a-priori Θ(k) cost per application. We show that when used to compute the classic happens-before (HB) partial order, tree clocks are optimal, in the sense that no other data structure can lead to smaller asymptotic running time. Moreover, we demonstrate that tree clocks can be used to compute other partial orders, such as schedulable-happens-before (SHB) and the standard Mazurkiewicz (MAZ) partial order, and thus are a versatile data structure. Our experiments show that just by replacing vector clocks with tree clocks, the computation becomes from 2.02 \texttimes{} faster (MAZ) to 2.66 \texttimes{} (SHB) and 2.97 \texttimes{} (HB) on average per benchmark. These results illustrate that tree clocks have the potential to become a standard data structure with wide applications in concurrent analyses.},
booktitle = {Proceedings of the 27th ACM International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {710–725},
numpages = {16},
keywords = {concurrency, dynamic analyses, happens-before, vector clocks},
location = {Lausanne, Switzerland},
series = {ASPLOS '22}
}]]></fr:meta>
            <fr:meta name="doi">10.1145/3503222.3507734</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>681</fr:anchor>
            <fr:addr type="user">mathur-pavlogiannis-viswanathan-syncp-2021</fr:addr>
            <fr:route>mathur-pavlogiannis-viswanathan-syncp-2021.xml</fr:route>
            <fr:title text="Optimal prediction of synchronization-preserving races">Optimal prediction of synchronization-preserving races</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>1</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="maheshviswanathan.xml" addr="maheshviswanathan" title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="bibtex"><![CDATA[@article{10.1145/3434317,
author = {Mathur, Umang and Pavlogiannis, Andreas and Viswanathan, Mahesh},
title = {Optimal prediction of synchronization-preserving races},
year = {2021},
issue_date = {January 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {POPL},
url = {https://doi.org/10.1145/3434317},
doi = {10.1145/3434317},
abstract = {Concurrent programs are notoriously hard to write correctly, as scheduling nondeterminism introduces subtle errors that are both hard to detect and to reproduce. The most common concurrency errors are (data) races, which occur when memory-conflicting actions are executed concurrently. Consequently, considerable effort has been made towards developing efficient techniques for race detection. The most common approach is dynamic race prediction: given an observed, race-free trace σ of a concurrent program, the task is to decide whether events of σ can be correctly reordered to a trace σ* that witnesses a race hidden in σ. In this work we introduce the notion of sync(hronization)-preserving races. A sync-preserving race occurs in σ when there is a witness σ* in which synchronization operations (e.g., acquisition and release of locks) appear in the same order as in σ. This is a broad definition that strictly subsumes the famous notion of happens-before races. Our main results are as follows. First, we develop a sound and complete algorithm for predicting sync-preserving races. For moderate values of parameters like the number of threads, the algorithm runs in \~{O}(N) time and space, where N is the length of the trace σ. Second, we show that the problem has a Ω(N/log2 N) space lower bound, and thus our algorithm is essentially time and space optimal. Third, we show that predicting races with even just a single reversal of two sync operations is NP-complete and even W1-hard when parameterized by the number of threads. Thus, sync-preservation characterizes exactly the tractability boundary of race prediction, and our algorithm is nearly optimal for the tractable side. Our experiments show that our algorithm is fast in practice, while sync-preservation characterizes races often missed by state-of-the-art methods.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {36},
numpages = {29},
keywords = {race detection, dynamic analysis, concurrency, complexity}
}]]></fr:meta>
            <fr:meta name="doi">10.1145/3434317</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>685</fr:anchor>
            <fr:addr type="user">mathur-pavlogiannis-viswanathan-2020</fr:addr>
            <fr:route>mathur-pavlogiannis-viswanathan-2020.xml</fr:route>
            <fr:title text="The Complexity of Dynamic Data Race Prediction">The Complexity of Dynamic Data Race Prediction</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2020</fr:year>
              <fr:month>7</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="maheshviswanathan.xml" addr="maheshviswanathan" title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{10.1145/3373718.3394783,
author = {Mathur, Umang and Pavlogiannis, Andreas and Viswanathan, Mahesh},
title = {The Complexity of Dynamic Data Race Prediction},
year = {2020},
isbn = {9781450371049},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3373718.3394783},
doi = {10.1145/3373718.3394783},
abstract = {Writing concurrent programs is notoriously hard due to scheduling non-determinism. The most common concurrency bugs are data races, which are accesses to a shared resource that can be executed concurrently. Dynamic data-race prediction is the most standard technique for detecting data races: given an observed, data-race-free trace t, the task is to determine whether t can be reordered to a trace t* that exposes a data-race. Although the problem has received significant practical attention for over three decades, its complexity has remained elusive. In this work, we address this lacuna, identifying sources of intractability and conditions under which the problem is efficiently solvable. Given a trace t of size n over k threads, our main results are as follows.First, we establish a general O(k · n2·(k-1) upper-bound, as well as an O(nk) upper-bound when certain parameters of t are constant. In addition, we show that the problem is NP-hard and even W[1]-hard parameterized by k, and thus unlikely to be fixed-parameter tractable. Second, we study the problem over acyclic communication topologies, such as server-clients hierarchies. We establish an O(k2 · d · n2 · log n) upper-bound, where d is the number of shared variables accessed in t. In addition, we show that even for traces with k = 2 threads, the problem has no O(n2-ϵ) algorithm under the Orthogonal Vectors conjecture. Since any trace with 2 threads defines an acyclic topology, our upper-bound for this case is optimal up to polynomial improvements for up to moderate values of k and d. Finally, motivated by existing heuristics, we study a distance-bounded version of the problem, where the task is to expose a data race by a witness trace that is similar to t. We develop an algorithm that works in O(n) time when certain parameters of t are constant.},
booktitle = {Proceedings of the 35th Annual ACM/IEEE Symposium on Logic in Computer Science},
pages = {713–727},
numpages = {15},
keywords = {Complexity, Data Race Prediction},
location = {Saarbr\"{u}cken, Germany},
series = {LICS '20}
}]]></fr:meta>
            <fr:meta name="doi">10.1145/3373718.3394783</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>689</fr:anchor>
            <fr:addr type="user">mathur-kini-viswanathan-shb-2018</fr:addr>
            <fr:route>mathur-kini-viswanathan-shb-2018.xml</fr:route>
            <fr:title text="What happens-after the first race? Enhancing the predictive power of happens-before based dynamic race detection">What happens-after the first race? Enhancing the predictive power of happens-before based dynamic race detection</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2018</fr:year>
              <fr:month>10</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
              </fr:author>
              <fr:author>Dileep Kini</fr:author>
              <fr:author>
                <fr:link type="local" href="maheshviswanathan.xml" addr="maheshviswanathan" title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="bibtex"><![CDATA[@article{10.1145/3276515,
author = {Mathur, Umang and Kini, Dileep and Viswanathan, Mahesh},
title = {What happens-after the first race? enhancing the predictive power of happens-before based dynamic race detection},
year = {2018},
issue_date = {November 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {OOPSLA},
url = {https://doi.org/10.1145/3276515},
doi = {10.1145/3276515},
abstract = {Dynamic race detection is the problem of determining if an observed program execution reveals the presence of a data race in a program. The classical approach to solving this problem is to detect if there is a pair of conflicting memory accesses that are unordered by Lamport’s happens-before (HB) relation. HB based race detection is known to not report false positives, i.e., it is sound. However, the soundness guarantee of HB only promises that the first pair of unordered, conflicting events is a schedulable data race. That is, there can be pairs of HB-unordered conflicting data accesses that are not schedulable races because there is no reordering of the events of the execution, where the events in race can be executed immediately after each other. We introduce a new partial order, called schedulable happens-before (SHB) that exactly characterizes the pairs of schedulable data races — every pair of conflicting data accesses that are identified by SHB can be scheduled, and every HB-race that can be scheduled is identified by SHB. Thus, the SHB partial order is truly sound. We present a linear time, vector clock algorithm to detect schedulable races using SHB. Our experiments demonstrate the value of our algorithm for dynamic race detection — SHB incurs only little performance overhead and can scale to executions from real-world software applications without compromising soundness.},
journal = {Proc. ACM Program. Lang.},
month = {oct},
articleno = {145},
numpages = {29},
keywords = {Concurrency, Dynamic Program Analysis, Happens-Before, Race Detection, Soundness}
}]]></fr:meta>
            <fr:meta name="doi">10.1145/3276515</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
          <fr:backmatter />
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>693</fr:anchor>
            <fr:addr type="user">kini-mathur-viswanathan-wcp-2017</fr:addr>
            <fr:route>kini-mathur-viswanathan-wcp-2017.xml</fr:route>
            <fr:title text="Dynamic race prediction in linear time">Dynamic race prediction in linear time</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:date>
              <fr:year>2017</fr:year>
              <fr:month>6</fr:month>
            </fr:date>
            <fr:authors>
              <fr:author>Dileep Kini</fr:author>
              <fr:author>
                <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
              </fr:author>
              <fr:author>
                <fr:link type="local" href="maheshviswanathan.xml" addr="maheshviswanathan" title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link>
              </fr:author>
            </fr:authors>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{10.1145/3062341.3062374,
author = {Kini, Dileep and Mathur, Umang and Viswanathan, Mahesh},
title = {Dynamic race prediction in linear time},
year = {2017},
isbn = {9781450349888},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3062341.3062374},
doi = {10.1145/3062341.3062374},
abstract = {Writing reliable concurrent software remains a huge challenge for today's programmers. Programmers rarely reason about their code by explicitly considering different possible inter-leavings of its execution. We consider the problem of detecting data races from individual executions in a sound manner. The classical approach to solving this problem has been to use Lamport's happens-before (HB) relation. Until now HB remains the only approach that runs in linear time. Previous efforts in improving over HB such as causally-precedes (CP) and maximal causal models fall short due to the fact that they are not implementable efficiently and hence have to compromise on their race detecting ability by limiting their techniques to bounded sized fragments of the execution. We present a new relation weak-causally-precedes (WCP) that is provably better than CP in terms of being able to detect more races, while still remaining sound. Moreover, it admits a linear time algorithm which works on the entire execution without having to fragment it.},
booktitle = {Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {157–170},
numpages = {14},
keywords = {Race Prediction, Online Algorithm, Concurrency},
location = {Barcelona, Spain},
series = {PLDI 2017}
}

@article{10.1145/3140587.3062374,
author = {Kini, Dileep and Mathur, Umang and Viswanathan, Mahesh},
title = {Dynamic race prediction in linear time},
year = {2017},
issue_date = {June 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/3140587.3062374},
doi = {10.1145/3140587.3062374},
abstract = {Writing reliable concurrent software remains a huge challenge for today's programmers. Programmers rarely reason about their code by explicitly considering different possible inter-leavings of its execution. We consider the problem of detecting data races from individual executions in a sound manner. The classical approach to solving this problem has been to use Lamport's happens-before (HB) relation. Until now HB remains the only approach that runs in linear time. Previous efforts in improving over HB such as causally-precedes (CP) and maximal causal models fall short due to the fact that they are not implementable efficiently and hence have to compromise on their race detecting ability by limiting their techniques to bounded sized fragments of the execution. We present a new relation weak-causally-precedes (WCP) that is provably better than CP in terms of being able to detect more races, while still remaining sound. Moreover, it admits a linear time algorithm which works on the entire execution without having to fragment it.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {157–170},
numpages = {14},
keywords = {Race Prediction, Online Algorithm, Concurrency}
}]]></fr:meta>
            <fr:meta name="doi">10.1145/3062341.3062374</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
          <fr:backmatter />
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
