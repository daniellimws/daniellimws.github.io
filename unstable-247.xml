<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
  <fr:frontmatter>
    <fr:anchor>861</fr:anchor>
    <fr:addr type="machine">#247</fr:addr>
    <fr:route>unstable-247.xml</fr:route>
    <fr:title text="Trace theory › papers"><fr:link type="local" href="dlws-0005.xml" addr="dlws-0005" title="Trace theory">Trace theory</fr:link> › papers</fr:title>
    <fr:authors>
      <fr:author>
        <fr:link type="local" href="daniellimws.xml" addr="daniellimws" title="Daniel Lim Wee Soong">Daniel Lim Wee Soong</fr:link>
      </fr:author>
    </fr:authors>
  </fr:frontmatter>
  <fr:mainmatter>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:anchor>320</fr:anchor>
        <fr:addr type="user">ang-mathur-prefix-2024</fr:addr>
        <fr:route>ang-mathur-prefix-2024.xml</fr:route>
        <fr:title text="Predictive Monitoring with Strong Trace Prefixes">Predictive Monitoring with Strong Trace Prefixes</fr:title>
        <fr:taxon>Reference</fr:taxon>
        <fr:date>
          <fr:year>2024</fr:year>
          <fr:month>7</fr:month>
        </fr:date>
        <fr:authors>
          <fr:author>
            <fr:link type="local" href="zhendongang.xml" addr="zhendongang" title="Zhendong Ang">Zhendong Ang</fr:link>
          </fr:author>
          <fr:author>
            <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
          </fr:author>
        </fr:authors>
        <fr:meta name="bibtex"><![CDATA[@InProceedings{10.1007/978-3-031-65630-9_9,
author="Ang, Zhendong
and Mathur, Umang",
editor="Gurfinkel, Arie
and Ganesh, Vijay",
title="Predictive Monitoring with Strong Trace Prefixes",
booktitle="Computer Aided Verification",
year="2024",
publisher="Springer Nature Switzerland",
address="Cham",
pages="182--204",
abstract="Runtime predictive analyses enhance coverage of traditional dynamic analyses based bug detection techniques by identifying a space of feasible reorderings of the observed execution and determining if any reordering in this space witnesses the violation of some desired safety property. The most popular approach for modelling the space of feasible reorderings is through Mazurkiewicz's trace equivalence. The simplicity of the framework also gives rise to efficient predictive analyses, and has been the de facto means for obtaining space and time efficient algorithms for monitoring concurrent programs.",
isbn="978-3-031-65630-9"
}]]></fr:meta>
        <fr:meta name="doi">10.1007/978-3-031-65630-9_9</fr:meta>
      </fr:frontmatter>
      <fr:mainmatter />
      <fr:backmatter />
    </fr:tree>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:anchor>323</fr:anchor>
        <fr:addr type="user">zheng-mathur-pavlogiannis-osr-2024</fr:addr>
        <fr:route>zheng-mathur-pavlogiannis-osr-2024.xml</fr:route>
        <fr:title text="Optimistic Prediction of Synchronization-Reversal Data Races">Optimistic Prediction of Synchronization-Reversal Data Races</fr:title>
        <fr:taxon>Reference</fr:taxon>
        <fr:date>
          <fr:year>2024</fr:year>
          <fr:month>4</fr:month>
        </fr:date>
        <fr:authors>
          <fr:author>
            <fr:link type="local" href="zhengshi.xml" addr="zhengshi" title="Zheng Shi">Zheng Shi</fr:link>
          </fr:author>
          <fr:author>
            <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
          </fr:author>
          <fr:author>
            <fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link>
          </fr:author>
        </fr:authors>
        <fr:meta name="bibtex"><![CDATA[@inproceedings{10.1145/3597503.3639099,
author = {Shi, Zheng and Mathur, Umang and Pavlogiannis, Andreas},
title = {Optimistic Prediction of Synchronization-Reversal Data Races},
year = {2024},
isbn = {9798400702174},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3597503.3639099},
doi = {10.1145/3597503.3639099},
abstract = {Dynamic data race detection has emerged as a key technique for ensuring reliability of concurrent software in practice. However, dynamic approaches can often miss data races owing to non-determinism in the thread scheduler. Predictive race detection techniques cater to this shortcoming by inferring alternate executions that may expose data races without re-executing the underlying program. More formally, the dynamic data race prediction problem asks, given a trace σ of an execution of a concurrent program, can σ be correctly reordered to expose a data race? Existing state-of-the art techniques for data race prediction either do not scale to executions arising from real world concurrent software, or only expose a limited class of data races, such as those that can be exposed without reversing the order of synchronization operations.In general, exposing data races by reasoning about synchronization reversals is an intractable problem. In this work, we identify a class of data races, called Optimistic Sync(hronization)-Reversal races that can be detected in a tractable manner and often include non-trivial data races that cannot be exposed by prior tractable techniques. We also propose a sound algorithm OSR for detecting all optimistic sync-reversal data races in overall quadratic time, and show that the algorithm is optimal by establishing a matching lower bound. Our experiments demonstrate the effectiveness of OSR--- on our extensive suite of benchmarks, OSR reports the largest number of data races, and scales well to large execution traces.},
booktitle = {Proceedings of the IEEE/ACM 46th International Conference on Software Engineering},
articleno = {134},
numpages = {13},
location = {Lisbon, Portugal},
series = {ICSE '24}
}]]></fr:meta>
        <fr:meta name="doi">10.1145/3597503.3639099</fr:meta>
      </fr:frontmatter>
      <fr:mainmatter />
      <fr:backmatter />
    </fr:tree>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:anchor>327</fr:anchor>
        <fr:addr type="user">farzan-mathur-grain-2024</fr:addr>
        <fr:route>farzan-mathur-grain-2024.xml</fr:route>
        <fr:title text="Coarser Equivalences for Causal Concurrency">Coarser Equivalences for Causal Concurrency</fr:title>
        <fr:taxon>Reference</fr:taxon>
        <fr:date>
          <fr:year>2024</fr:year>
          <fr:month>1</fr:month>
        </fr:date>
        <fr:authors>
          <fr:author>
            <fr:link type="local" href="azadehfarzan.xml" addr="azadehfarzan" title="Azadeh Farzan">Azadeh Farzan</fr:link>
          </fr:author>
          <fr:author>
            <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
          </fr:author>
        </fr:authors>
        <fr:meta name="bibtex"><![CDATA[@article{10.1145/3632873,
author = {Farzan, Azadeh and Mathur, Umang},
title = {Coarser Equivalences for Causal Concurrency},
year = {2024},
issue_date = {January 2024},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {POPL},
url = {https://doi.org/10.1145/3632873},
doi = {10.1145/3632873},
abstract = {Trace theory (formulated by Mazurkiewicz in 1987) is a principled framework for defining equivalence relations for concurrent program runs based on a commutativity relation over the set of atomic steps taken by individual program threads. Its simplicity, elegance, and algorithmic efficiency makes it useful in many different contexts including program verification and testing. It is well-understood that the larger the equivalence classes are, the more benefits they would bring to the algorithms and applications that use them. In this paper, we study relaxations of trace equivalence with the goal of maintaining its algorithmic advantages. We first prove that the largest appropriate relaxation of trace equivalence, an equivalence relation that preserves the order of steps taken by each thread and what write operation each read operation observes, does not yield efficient algorithms. Specifically, we prove a linear space lower bound for the problem of checking, in a streaming setting, if two arbitrary steps of a concurrent program run are causally concurrent (i.e. they can be reordered in an equivalent run) or causally ordered (i.e. they always appear in the same order in all equivalent runs). The same problem can be decided in constant space for trace equivalence. Next, we propose a new commutativity-based notion of equivalence called grain equivalence that is strictly more relaxed than trace equivalence, and yet yields a constant space algorithm for the same problem. This notion of equivalence uses commutativity of grains, which are sequences of atomic steps, in addition to the standard commutativity from trace theory. We study the two distinct cases when the grains are contiguous subwords of the input program run and when they are not, formulate the precise definition of causal concurrency in each case, and show that they can be decided in constant space, despite being strict relaxations of the notion of causal concurrency based on trace equivalence.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {31},
numpages = {31},
keywords = {concurrency, equivalence, predictive analysis, reads-from, reduction}
}]]></fr:meta>
        <fr:meta name="doi">10.1145/3632873</fr:meta>
      </fr:frontmatter>
      <fr:mainmatter />
      <fr:backmatter />
    </fr:tree>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:anchor>330</fr:anchor>
        <fr:addr type="user">ang-mathur-pattern-2024</fr:addr>
        <fr:route>ang-mathur-pattern-2024.xml</fr:route>
        <fr:title text="Predictive Monitoring against Pattern Regular Languages">Predictive Monitoring against Pattern Regular Languages</fr:title>
        <fr:taxon>Reference</fr:taxon>
        <fr:date>
          <fr:year>2024</fr:year>
          <fr:month>1</fr:month>
        </fr:date>
        <fr:authors>
          <fr:author>
            <fr:link type="local" href="zhendongang.xml" addr="zhendongang" title="Zhendong Ang">Zhendong Ang</fr:link>
          </fr:author>
          <fr:author>
            <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
          </fr:author>
        </fr:authors>
        <fr:meta name="bibtex"><![CDATA[@article{10.1145/3632915,
author = {Ang, Zhendong and Mathur, Umang},
title = {Predictive Monitoring against Pattern Regular Languages},
year = {2024},
issue_date = {January 2024},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {POPL},
url = {https://doi.org/10.1145/3632915},
doi = {10.1145/3632915},
abstract = {While current bug detection techniques for concurrent software focus on unearthing low-level issues such as data races or deadlocks, they often fall short of discovering more intricate temporal behaviours that can arise even in the absence of such low-level issues. In this paper, we focus on the problem of dynamically analysing concurrent software against high-level temporal specifications such as LTL. Existing techniques for runtime monitoring against such specifications are primarily designed for sequential software and remain inadequate in the presence of concurrency — violations may be observed only in intricate thread interleavings, requiring many re-runs of the underlying software in conjunction with the analysis. Towards this, we study the problem of predictive runtime monitoring, inspired by the analogous problem of predictive data race detection studied extensively recently. The predictive runtime monitoring question asks, given an execution σ, if it can be soundly reordered to expose violations of a specification. In general, this problem may become easily intractable when either the specifications or the notion of reorderings used is complex. In this paper, we focus on specifications that are given in regular languages. Our notion of reorderings is trace equivalence, where an execution is considered a reordering of another if it can be obtained from the latter by successively commuting adjacent independent actions. We first show that, even in this simplistic setting, the problem of predictive monitoring admits a super-linear lower bound of O(nα), where n is the number of events in the execution, and α is a parameter describing the degree of commutativity, and typically corresponds to the number of threads in the execution. As a result, predictive runtime monitoring even in this setting is unlikely to be efficiently solvable, unlike in the non-predictive setting where the problem can be checked using a deterministic finite automaton (and thus, a constant-space streaming linear-time algorithm). Towards this, we identify a sub-class of regular languages, called pattern languages (and their extension generalized pattern languages). Pattern languages can naturally express specific ordering of some number of (labelled) events, and have been inspired by popular empirical hypotheses underlying many concurrency bug detection approaches such as the “small bug depth” hypothesis. More importantly, we show that for pattern (and generalized pattern) languages, the predictive monitoring problem can be solved using a constant-space streaming linear-time algorithm. We implement and evaluate our algorithm PatternTrack on benchmarks from the literature and show that it is effective in monitoring large-scale applications.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {73},
numpages = {35},
keywords = {complexity, concurrency, dynamic analysis, predictive monitoring}
}]]></fr:meta>
        <fr:meta name="doi">10.1145/3632915</fr:meta>
      </fr:frontmatter>
      <fr:mainmatter />
      <fr:backmatter />
    </fr:tree>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:anchor>333</fr:anchor>
        <fr:addr type="user">mathur-pavlogiannis-viswanathan-syncp-2021</fr:addr>
        <fr:route>mathur-pavlogiannis-viswanathan-syncp-2021.xml</fr:route>
        <fr:title text="Optimal prediction of synchronization-preserving races">Optimal prediction of synchronization-preserving races</fr:title>
        <fr:taxon>Reference</fr:taxon>
        <fr:date>
          <fr:year>2021</fr:year>
          <fr:month>1</fr:month>
        </fr:date>
        <fr:authors>
          <fr:author>
            <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
          </fr:author>
          <fr:author>
            <fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link>
          </fr:author>
          <fr:author>
            <fr:link type="local" href="maheshviswanathan.xml" addr="maheshviswanathan" title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link>
          </fr:author>
        </fr:authors>
        <fr:meta name="bibtex"><![CDATA[@article{10.1145/3434317,
author = {Mathur, Umang and Pavlogiannis, Andreas and Viswanathan, Mahesh},
title = {Optimal prediction of synchronization-preserving races},
year = {2021},
issue_date = {January 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {POPL},
url = {https://doi.org/10.1145/3434317},
doi = {10.1145/3434317},
abstract = {Concurrent programs are notoriously hard to write correctly, as scheduling nondeterminism introduces subtle errors that are both hard to detect and to reproduce. The most common concurrency errors are (data) races, which occur when memory-conflicting actions are executed concurrently. Consequently, considerable effort has been made towards developing efficient techniques for race detection. The most common approach is dynamic race prediction: given an observed, race-free trace σ of a concurrent program, the task is to decide whether events of σ can be correctly reordered to a trace σ* that witnesses a race hidden in σ. In this work we introduce the notion of sync(hronization)-preserving races. A sync-preserving race occurs in σ when there is a witness σ* in which synchronization operations (e.g., acquisition and release of locks) appear in the same order as in σ. This is a broad definition that strictly subsumes the famous notion of happens-before races. Our main results are as follows. First, we develop a sound and complete algorithm for predicting sync-preserving races. For moderate values of parameters like the number of threads, the algorithm runs in \~{O}(N) time and space, where N is the length of the trace σ. Second, we show that the problem has a Ω(N/log2 N) space lower bound, and thus our algorithm is essentially time and space optimal. Third, we show that predicting races with even just a single reversal of two sync operations is NP-complete and even W1-hard when parameterized by the number of threads. Thus, sync-preservation characterizes exactly the tractability boundary of race prediction, and our algorithm is nearly optimal for the tractable side. Our experiments show that our algorithm is fast in practice, while sync-preservation characterizes races often missed by state-of-the-art methods.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {36},
numpages = {29},
keywords = {race detection, dynamic analysis, concurrency, complexity}
}]]></fr:meta>
        <fr:meta name="doi">10.1145/3434317</fr:meta>
      </fr:frontmatter>
      <fr:mainmatter />
      <fr:backmatter />
    </fr:tree>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:anchor>337</fr:anchor>
        <fr:addr type="user">mathur-pavlogiannis-viswanathan-2020</fr:addr>
        <fr:route>mathur-pavlogiannis-viswanathan-2020.xml</fr:route>
        <fr:title text="The Complexity of Dynamic Data Race Prediction">The Complexity of Dynamic Data Race Prediction</fr:title>
        <fr:taxon>Reference</fr:taxon>
        <fr:date>
          <fr:year>2020</fr:year>
          <fr:month>7</fr:month>
        </fr:date>
        <fr:authors>
          <fr:author>
            <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
          </fr:author>
          <fr:author>
            <fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link>
          </fr:author>
          <fr:author>
            <fr:link type="local" href="maheshviswanathan.xml" addr="maheshviswanathan" title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link>
          </fr:author>
        </fr:authors>
        <fr:meta name="bibtex"><![CDATA[@inproceedings{10.1145/3373718.3394783,
author = {Mathur, Umang and Pavlogiannis, Andreas and Viswanathan, Mahesh},
title = {The Complexity of Dynamic Data Race Prediction},
year = {2020},
isbn = {9781450371049},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3373718.3394783},
doi = {10.1145/3373718.3394783},
abstract = {Writing concurrent programs is notoriously hard due to scheduling non-determinism. The most common concurrency bugs are data races, which are accesses to a shared resource that can be executed concurrently. Dynamic data-race prediction is the most standard technique for detecting data races: given an observed, data-race-free trace t, the task is to determine whether t can be reordered to a trace t* that exposes a data-race. Although the problem has received significant practical attention for over three decades, its complexity has remained elusive. In this work, we address this lacuna, identifying sources of intractability and conditions under which the problem is efficiently solvable. Given a trace t of size n over k threads, our main results are as follows.First, we establish a general O(k · n2·(k-1) upper-bound, as well as an O(nk) upper-bound when certain parameters of t are constant. In addition, we show that the problem is NP-hard and even W[1]-hard parameterized by k, and thus unlikely to be fixed-parameter tractable. Second, we study the problem over acyclic communication topologies, such as server-clients hierarchies. We establish an O(k2 · d · n2 · log n) upper-bound, where d is the number of shared variables accessed in t. In addition, we show that even for traces with k = 2 threads, the problem has no O(n2-ϵ) algorithm under the Orthogonal Vectors conjecture. Since any trace with 2 threads defines an acyclic topology, our upper-bound for this case is optimal up to polynomial improvements for up to moderate values of k and d. Finally, motivated by existing heuristics, we study a distance-bounded version of the problem, where the task is to expose a data race by a witness trace that is similar to t. We develop an algorithm that works in O(n) time when certain parameters of t are constant.},
booktitle = {Proceedings of the 35th Annual ACM/IEEE Symposium on Logic in Computer Science},
pages = {713–727},
numpages = {15},
keywords = {Complexity, Data Race Prediction},
location = {Saarbr\"{u}cken, Germany},
series = {LICS '20}
}]]></fr:meta>
        <fr:meta name="doi">10.1145/3373718.3394783</fr:meta>
      </fr:frontmatter>
      <fr:mainmatter />
      <fr:backmatter />
    </fr:tree>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:anchor>341</fr:anchor>
        <fr:addr type="user">pavlogiannis-m2-2019</fr:addr>
        <fr:route>pavlogiannis-m2-2019.xml</fr:route>
        <fr:title text="Fast, sound, and effectively complete dynamic race prediction">Fast, sound, and effectively complete dynamic race prediction</fr:title>
        <fr:taxon>Reference</fr:taxon>
        <fr:date>
          <fr:year>2019</fr:year>
          <fr:month>12</fr:month>
        </fr:date>
        <fr:authors>
          <fr:author>
            <fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link>
          </fr:author>
        </fr:authors>
        <fr:meta name="bibtex"><![CDATA[@article{10.1145/3371085,
author = {Pavlogiannis, Andreas},
title = {Fast, sound, and effectively complete dynamic race prediction},
year = {2019},
issue_date = {January 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {POPL},
url = {https://doi.org/10.1145/3371085},
doi = {10.1145/3371085},
abstract = {Writing concurrent programs is highly error-prone due to the nondeterminism in interprocess communication. The most reliable indicators of errors in concurrency are data races, which are accesses to a shared resource that can be executed concurrently. We study the problem of predicting data races in lock-based concurrent programs. The input consists of a concurrent trace t, and the task is to determine all pairs of events of t that constitute a data race. The problem lies at the heart of concurrent verification and has been extensively studied for over three decades. However, existing polynomial-time sound techniques are highly incomplete and can miss simple races. In this work we develop M2: a new polynomial-time algorithm for this problem, which has no false positives. In addition, our algorithm is complete for input traces that consist of two processes, i.e., it provably detects all races in the trace. We also develop sufficient criteria for detecting completeness dynamically in cases of more than two processes. We make an experimental evaluation of our algorithm on a challenging set of benchmarks taken from recent literature on the topic. Our algorithm soundly reports hundreds of real races, many of which are missed by existing methods. In addition, using our dynamic completeness criteria, M2 concludes that it has detected all races in the benchmark set, hence the reports are both sound and complete. Finally, its running times are comparable, and often smaller than the theoretically fastest, yet highly incomplete, existing methods. To our knowledge, M2 is the first sound algorithm that achieves such a level of performance on both running time and completeness of the reported races.},
journal = {Proc. ACM Program. Lang.},
month = {dec},
articleno = {17},
numpages = {29},
keywords = {race detection, predictive analyses, concurrency}
}]]></fr:meta>
        <fr:meta name="doi">10.1145/3371085</fr:meta>
      </fr:frontmatter>
      <fr:mainmatter />
      <fr:backmatter />
    </fr:tree>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:anchor>343</fr:anchor>
        <fr:addr type="user">mathur-kini-viswanathan-shb-2018</fr:addr>
        <fr:route>mathur-kini-viswanathan-shb-2018.xml</fr:route>
        <fr:title text="What happens-after the first race? Enhancing the predictive power of happens-before based dynamic race detection">What happens-after the first race? Enhancing the predictive power of happens-before based dynamic race detection</fr:title>
        <fr:taxon>Reference</fr:taxon>
        <fr:date>
          <fr:year>2018</fr:year>
          <fr:month>10</fr:month>
        </fr:date>
        <fr:authors>
          <fr:author>
            <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
          </fr:author>
          <fr:author>Dileep Kini</fr:author>
          <fr:author>
            <fr:link type="local" href="maheshviswanathan.xml" addr="maheshviswanathan" title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link>
          </fr:author>
        </fr:authors>
        <fr:meta name="bibtex"><![CDATA[@article{10.1145/3276515,
author = {Mathur, Umang and Kini, Dileep and Viswanathan, Mahesh},
title = {What happens-after the first race? enhancing the predictive power of happens-before based dynamic race detection},
year = {2018},
issue_date = {November 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {OOPSLA},
url = {https://doi.org/10.1145/3276515},
doi = {10.1145/3276515},
abstract = {Dynamic race detection is the problem of determining if an observed program execution reveals the presence of a data race in a program. The classical approach to solving this problem is to detect if there is a pair of conflicting memory accesses that are unordered by Lamport’s happens-before (HB) relation. HB based race detection is known to not report false positives, i.e., it is sound. However, the soundness guarantee of HB only promises that the first pair of unordered, conflicting events is a schedulable data race. That is, there can be pairs of HB-unordered conflicting data accesses that are not schedulable races because there is no reordering of the events of the execution, where the events in race can be executed immediately after each other. We introduce a new partial order, called schedulable happens-before (SHB) that exactly characterizes the pairs of schedulable data races — every pair of conflicting data accesses that are identified by SHB can be scheduled, and every HB-race that can be scheduled is identified by SHB. Thus, the SHB partial order is truly sound. We present a linear time, vector clock algorithm to detect schedulable races using SHB. Our experiments demonstrate the value of our algorithm for dynamic race detection — SHB incurs only little performance overhead and can scale to executions from real-world software applications without compromising soundness.},
journal = {Proc. ACM Program. Lang.},
month = {oct},
articleno = {145},
numpages = {29},
keywords = {Concurrency, Dynamic Program Analysis, Happens-Before, Race Detection, Soundness}
}]]></fr:meta>
        <fr:meta name="doi">10.1145/3276515</fr:meta>
      </fr:frontmatter>
      <fr:mainmatter />
      <fr:backmatter />
    </fr:tree>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:anchor>347</fr:anchor>
        <fr:addr type="user">kini-mathur-viswanathan-wcp-2017</fr:addr>
        <fr:route>kini-mathur-viswanathan-wcp-2017.xml</fr:route>
        <fr:title text="Dynamic race prediction in linear time">Dynamic race prediction in linear time</fr:title>
        <fr:taxon>Reference</fr:taxon>
        <fr:date>
          <fr:year>2017</fr:year>
          <fr:month>6</fr:month>
        </fr:date>
        <fr:authors>
          <fr:author>Dileep Kini</fr:author>
          <fr:author>
            <fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link>
          </fr:author>
          <fr:author>
            <fr:link type="local" href="maheshviswanathan.xml" addr="maheshviswanathan" title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link>
          </fr:author>
        </fr:authors>
        <fr:meta name="bibtex"><![CDATA[@inproceedings{10.1145/3062341.3062374,
author = {Kini, Dileep and Mathur, Umang and Viswanathan, Mahesh},
title = {Dynamic race prediction in linear time},
year = {2017},
isbn = {9781450349888},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3062341.3062374},
doi = {10.1145/3062341.3062374},
abstract = {Writing reliable concurrent software remains a huge challenge for today's programmers. Programmers rarely reason about their code by explicitly considering different possible inter-leavings of its execution. We consider the problem of detecting data races from individual executions in a sound manner. The classical approach to solving this problem has been to use Lamport's happens-before (HB) relation. Until now HB remains the only approach that runs in linear time. Previous efforts in improving over HB such as causally-precedes (CP) and maximal causal models fall short due to the fact that they are not implementable efficiently and hence have to compromise on their race detecting ability by limiting their techniques to bounded sized fragments of the execution. We present a new relation weak-causally-precedes (WCP) that is provably better than CP in terms of being able to detect more races, while still remaining sound. Moreover, it admits a linear time algorithm which works on the entire execution without having to fragment it.},
booktitle = {Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {157–170},
numpages = {14},
keywords = {Race Prediction, Online Algorithm, Concurrency},
location = {Barcelona, Spain},
series = {PLDI 2017}
}

@article{10.1145/3140587.3062374,
author = {Kini, Dileep and Mathur, Umang and Viswanathan, Mahesh},
title = {Dynamic race prediction in linear time},
year = {2017},
issue_date = {June 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/3140587.3062374},
doi = {10.1145/3140587.3062374},
abstract = {Writing reliable concurrent software remains a huge challenge for today's programmers. Programmers rarely reason about their code by explicitly considering different possible inter-leavings of its execution. We consider the problem of detecting data races from individual executions in a sound manner. The classical approach to solving this problem has been to use Lamport's happens-before (HB) relation. Until now HB remains the only approach that runs in linear time. Previous efforts in improving over HB such as causally-precedes (CP) and maximal causal models fall short due to the fact that they are not implementable efficiently and hence have to compromise on their race detecting ability by limiting their techniques to bounded sized fragments of the execution. We present a new relation weak-causally-precedes (WCP) that is provably better than CP in terms of being able to detect more races, while still remaining sound. Moreover, it admits a linear time algorithm which works on the entire execution without having to fragment it.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {157–170},
numpages = {14},
keywords = {Race Prediction, Online Algorithm, Concurrency}
}]]></fr:meta>
        <fr:meta name="doi">10.1145/3062341.3062374</fr:meta>
      </fr:frontmatter>
      <fr:mainmatter />
      <fr:backmatter />
    </fr:tree>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:anchor>351</fr:anchor>
        <fr:addr type="user">huang-meredith-rosu-rvpredict-2014</fr:addr>
        <fr:route>huang-meredith-rosu-rvpredict-2014.xml</fr:route>
        <fr:title text="Maximal sound predictive race detection with control flow abstraction">Maximal sound predictive race detection with control flow abstraction</fr:title>
        <fr:taxon>Reference</fr:taxon>
        <fr:date>
          <fr:year>2014</fr:year>
          <fr:month>6</fr:month>
        </fr:date>
        <fr:authors>
          <fr:author>Jeff Huang</fr:author>
          <fr:author>Patrick O’Neil Meredith</fr:author>
          <fr:author>
            <fr:link type="local" href="grigorerosu.xml" addr="grigorerosu" title="Grigore Rosu">Grigore Rosu</fr:link>
          </fr:author>
        </fr:authors>
        <fr:meta name="bibtex"><![CDATA[@inproceedings{10.1145/2594291.2594315,
author = {Huang, Jeff and Meredith, Patrick O'Neil and Rosu, Grigore},
title = {Maximal sound predictive race detection with control flow abstraction},
year = {2014},
isbn = {9781450327848},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2594291.2594315},
doi = {10.1145/2594291.2594315},
abstract = {Despite the numerous static and dynamic program analysis techniques in the literature, data races remain one of the most common bugs in modern concurrent software. Further, the techniques that do exist either have limited detection capability or are unsound, meaning that they report false positives. We present a sound race detection technique that achieves a provably higher detection capability than existing sound techniques. A key insight of our technique is the inclusion of abstracted control flow information into the execution model, which increases the space of the causal model permitted by classical happens-before or causally-precedes based detectors. By encoding the control flow and a minimal set of feasibility constraints as a group of first-order logic formulae, we formulate race detection as a constraint solving problem. Moreover, we formally prove that our formulation achieves the maximal possible detection capability for any sound dynamic race detector with respect to the same input trace under the sequential consistency memory model. We demonstrate via extensive experimentation that our technique detects more races than the other state-of-the-art sound race detection techniques, and that it is scalable to executions of real world concurrent applications with tens of millions of critical events. These experiments also revealed several previously unknown races in real systems (e.g., Eclipse) that have been confirmed or fixed by the developers. Our tool is also adopted by Eclipse developers.},
booktitle = {Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {337–348},
numpages = {12},
keywords = {control flow, data race, maximal sound, prediction},
location = {Edinburgh, United Kingdom},
series = {PLDI '14}
}

@article{10.1145/2666356.2594315,
author = {Huang, Jeff and Meredith, Patrick O'Neil and Rosu, Grigore},
title = {Maximal sound predictive race detection with control flow abstraction},
year = {2014},
issue_date = {June 2014},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {49},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/2666356.2594315},
doi = {10.1145/2666356.2594315},
abstract = {Despite the numerous static and dynamic program analysis techniques in the literature, data races remain one of the most common bugs in modern concurrent software. Further, the techniques that do exist either have limited detection capability or are unsound, meaning that they report false positives. We present a sound race detection technique that achieves a provably higher detection capability than existing sound techniques. A key insight of our technique is the inclusion of abstracted control flow information into the execution model, which increases the space of the causal model permitted by classical happens-before or causally-precedes based detectors. By encoding the control flow and a minimal set of feasibility constraints as a group of first-order logic formulae, we formulate race detection as a constraint solving problem. Moreover, we formally prove that our formulation achieves the maximal possible detection capability for any sound dynamic race detector with respect to the same input trace under the sequential consistency memory model. We demonstrate via extensive experimentation that our technique detects more races than the other state-of-the-art sound race detection techniques, and that it is scalable to executions of real world concurrent applications with tens of millions of critical events. These experiments also revealed several previously unknown races in real systems (e.g., Eclipse) that have been confirmed or fixed by the developers. Our tool is also adopted by Eclipse developers.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {337–348},
numpages = {12},
keywords = {control flow, data race, maximal sound, prediction}
}]]></fr:meta>
        <fr:meta name="doi">10.1145/2594291.2594315</fr:meta>
      </fr:frontmatter>
      <fr:mainmatter />
      <fr:backmatter />
    </fr:tree>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:anchor>355</fr:anchor>
        <fr:addr type="user">smaragdakis-cp-2012</fr:addr>
        <fr:route>smaragdakis-cp-2012.xml</fr:route>
        <fr:title text="Sound predictive race detection in polynomial time">Sound predictive race detection in polynomial time</fr:title>
        <fr:taxon>Reference</fr:taxon>
        <fr:date>
          <fr:year>2012</fr:year>
          <fr:month>1</fr:month>
        </fr:date>
        <fr:authors>
          <fr:author>Yannis Smaragdakis</fr:author>
          <fr:author>Jacob M. Evans</fr:author>
          <fr:author>Caitlin Sadowski</fr:author>
          <fr:author>Jaeheon Yi</fr:author>
          <fr:author>Cormac Flanagan</fr:author>
        </fr:authors>
        <fr:meta name="bibtex"><![CDATA[@inproceedings{10.1145/2103656.2103702,
author = {Smaragdakis, Yannis and Evans, Jacob and Sadowski, Caitlin and Yi, Jaeheon and Flanagan, Cormac},
title = {Sound predictive race detection in polynomial time},
year = {2012},
isbn = {9781450310833},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2103656.2103702},
doi = {10.1145/2103656.2103702},
abstract = {Data races are among the most reliable indicators of programming errors in concurrent software. For at least two decades, Lamport's happens-before (HB) relation has served as the standard test for detecting races--other techniques, such as lockset-based approaches, fail to be sound, as they may falsely warn of races. This work introduces a new relation, causally-precedes (CP), which generalizes happens-before to observe more races without sacrificing soundness. Intuitively, CP tries to capture the concept of happens-before ordered events that must occur in the observed order for the program to observe the same values. What distinguishes CP from past predictive race detection approaches (which also generalize an observed execution to detect races in other plausible executions) is that CP-based race detection is both sound and of polynomial complexity. We demonstrate that the unique aspects of CP result in practical benefit. Applying CP to real-world programs, we successfully analyze server-level applications (e.g., Apache FtpServer) and show that traces longer than in past predictive race analyses can be analyzed in mere seconds to a few minutes. For these programs, CP race detection uncovers races that are hard to detect by repeated execution and HB race detection: a single run of CP race detection produces several races not discovered by 10 separate rounds of happens-before race detection.},
booktitle = {Proceedings of the 39th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {387–400},
numpages = {14},
keywords = {dynamic analysis, happens-before, race detection},
location = {Philadelphia, PA, USA},
series = {POPL '12}
}

@article{10.1145/2103621.2103702,
author = {Smaragdakis, Yannis and Evans, Jacob and Sadowski, Caitlin and Yi, Jaeheon and Flanagan, Cormac},
title = {Sound predictive race detection in polynomial time},
year = {2012},
issue_date = {January 2012},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {47},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/2103621.2103702},
doi = {10.1145/2103621.2103702},
abstract = {Data races are among the most reliable indicators of programming errors in concurrent software. For at least two decades, Lamport's happens-before (HB) relation has served as the standard test for detecting races--other techniques, such as lockset-based approaches, fail to be sound, as they may falsely warn of races. This work introduces a new relation, causally-precedes (CP), which generalizes happens-before to observe more races without sacrificing soundness. Intuitively, CP tries to capture the concept of happens-before ordered events that must occur in the observed order for the program to observe the same values. What distinguishes CP from past predictive race detection approaches (which also generalize an observed execution to detect races in other plausible executions) is that CP-based race detection is both sound and of polynomial complexity. We demonstrate that the unique aspects of CP result in practical benefit. Applying CP to real-world programs, we successfully analyze server-level applications (e.g., Apache FtpServer) and show that traces longer than in past predictive race analyses can be analyzed in mere seconds to a few minutes. For these programs, CP race detection uncovers races that are hard to detect by repeated execution and HB race detection: a single run of CP race detection produces several races not discovered by 10 separate rounds of happens-before race detection.},
journal = {SIGPLAN Not.},
month = {jan},
pages = {387–400},
numpages = {14},
keywords = {dynamic analysis, happens-before, race detection}
}]]></fr:meta>
        <fr:meta name="doi">10.1145/2103656.2103702</fr:meta>
      </fr:frontmatter>
      <fr:mainmatter />
      <fr:backmatter />
    </fr:tree>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:anchor>361</fr:anchor>
        <fr:addr type="user">mazurkiewicz-trace-1986</fr:addr>
        <fr:route>mazurkiewicz-trace-1986.xml</fr:route>
        <fr:title text="Trace Theory">Trace Theory</fr:title>
        <fr:taxon>Reference</fr:taxon>
        <fr:date>
          <fr:year>1987</fr:year>
        </fr:date>
        <fr:authors>
          <fr:author>Antoni Mazurkiewicz</fr:author>
        </fr:authors>
        <fr:meta name="bibtex"><![CDATA[@InProceedings{10.1007/3-540-17906-2_30,
author="Mazurkiewicz, Antoni",
editor="Brauer, W.
and Reisig, W.
and Rozenberg, G.",
title="Trace theory",
booktitle="Petri Nets: Applications and Relationships to Other Models of Concurrency",
year="1987",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="278--324",
abstract="The concept of traces has been introduced for describing non-sequential behaviour of concurrent systems via its sequential observations. Traces represent concurrent processes in the same way as strings represent sequential ones. The theory of traces can be used as a tool for reasoning about nets and it is hoped that applying this theory one can get a calculus of the concurrent processes anologous to that available for sequential systems. The following topics will be discussed: algebraic properties of traces, trace models of some concurrency phenomena, fixed-point calculus for finding the behaviour of nets, modularity, and some applications of the presented theory.",
isbn="978-3-540-47926-0"
}]]></fr:meta>
        <fr:meta name="doi">10.1007/3-540-17906-2_30</fr:meta>
      </fr:frontmatter>
      <fr:mainmatter />
      <fr:backmatter />
    </fr:tree>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:anchor>363</fr:anchor>
        <fr:addr type="user">lamport-clocks-1978</fr:addr>
        <fr:route>lamport-clocks-1978.xml</fr:route>
        <fr:title text="Time, clocks, and the ordering of events in a distributed system">Time, clocks, and the ordering of events in a distributed system</fr:title>
        <fr:taxon>Reference</fr:taxon>
        <fr:date>
          <fr:year>1978</fr:year>
          <fr:month>7</fr:month>
        </fr:date>
        <fr:authors>
          <fr:author>Leslie Lamport</fr:author>
        </fr:authors>
        <fr:meta name="bibtex"><![CDATA[@article{10.1145/359545.359563,
author = {Lamport, Leslie},
title = {Time, clocks, and the ordering of events in a distributed system},
year = {1978},
issue_date = {July 1978},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {21},
number = {7},
issn = {0001-0782},
url = {https://doi.org/10.1145/359545.359563},
doi = {10.1145/359545.359563},
abstract = {The concept of one event happening before another in a distributed system is examined, and is shown to define a partial ordering of the events. A distributed algorithm is given for synchronizing a system of logical clocks which can be used to totally order the events. The use of the total ordering is illustrated with a method for solving synchronization problems. The algorithm is then specialized for synchronizing physical clocks, and a bound is derived on how far out of synchrony the clocks can become.},
journal = {Commun. ACM},
month = {jul},
pages = {558–565},
numpages = {8},
keywords = {multiprocess systems, distributed systems, computer networks, clock synchronization}
}]]></fr:meta>
        <fr:meta name="doi">10.1145/359545.359563</fr:meta>
      </fr:frontmatter>
      <fr:mainmatter />
      <fr:backmatter />
    </fr:tree>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:title text="Context">Context</fr:title>
        <fr:authors />
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>863</fr:anchor>
            <fr:addr type="user">dlws-0005</fr:addr>
            <fr:route>dlws-0005.xml</fr:route>
            <fr:title text="Trace theory">Trace theory</fr:title>
            <fr:taxon>Bibliography</fr:taxon>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>8</fr:month>
              <fr:day>23</fr:day>
            </fr:date>
            <fr:authors>
              <fr:author>
                <fr:link type="local" href="daniellimws.xml" addr="daniellimws" title="Daniel Lim Wee Soong">Daniel Lim Wee Soong</fr:link>
              </fr:author>
            </fr:authors>
          </fr:frontmatter>
          <fr:mainmatter><fr:p>This page collects papers and dissertations about Trace Theory; if you have written a paper or dissertation on this topic, please <fr:link type="external" href="mailto:dws.lim@nus.edu.sg">write to me</fr:link> to have it added to this list.</fr:p><fr:p>In particular, many of the works in this list apply Trace Theory to the <fr:link type="local" href="dlws-0004.xml" addr="dlws-0004" title="Race prediction">Race Prediction</fr:link> problem.</fr:p>
  <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>318</fr:anchor><fr:addr type="machine">#247</fr:addr><fr:route>unstable-247.xml</fr:route><fr:title text="Papers">Papers</fr:title><fr:authors><fr:author><fr:link type="local" href="daniellimws.xml" addr="daniellimws" title="Daniel Lim Wee Soong">Daniel Lim Wee Soong</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>320</fr:anchor><fr:addr type="user">ang-mathur-prefix-2024</fr:addr><fr:route>ang-mathur-prefix-2024.xml</fr:route><fr:title text="Predictive Monitoring with Strong Trace Prefixes">Predictive Monitoring with Strong Trace Prefixes</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month></fr:date><fr:authors><fr:author><fr:link type="local" href="zhendongang.xml" addr="zhendongang" title="Zhendong Ang">Zhendong Ang</fr:link></fr:author><fr:author><fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link></fr:author></fr:authors><fr:meta name="bibtex"><![CDATA[@InProceedings{10.1007/978-3-031-65630-9_9,
author="Ang, Zhendong
and Mathur, Umang",
editor="Gurfinkel, Arie
and Ganesh, Vijay",
title="Predictive Monitoring with Strong Trace Prefixes",
booktitle="Computer Aided Verification",
year="2024",
publisher="Springer Nature Switzerland",
address="Cham",
pages="182--204",
abstract="Runtime predictive analyses enhance coverage of traditional dynamic analyses based bug detection techniques by identifying a space of feasible reorderings of the observed execution and determining if any reordering in this space witnesses the violation of some desired safety property. The most popular approach for modelling the space of feasible reorderings is through Mazurkiewicz's trace equivalence. The simplicity of the framework also gives rise to efficient predictive analyses, and has been the de facto means for obtaining space and time efficient algorithms for monitoring concurrent programs.",
isbn="978-3-031-65630-9"
}]]></fr:meta><fr:meta name="doi">10.1007/978-3-031-65630-9_9</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>323</fr:anchor><fr:addr type="user">zheng-mathur-pavlogiannis-osr-2024</fr:addr><fr:route>zheng-mathur-pavlogiannis-osr-2024.xml</fr:route><fr:title text="Optimistic Prediction of Synchronization-Reversal Data Races">Optimistic Prediction of Synchronization-Reversal Data Races</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month></fr:date><fr:authors><fr:author><fr:link type="local" href="zhengshi.xml" addr="zhengshi" title="Zheng Shi">Zheng Shi</fr:link></fr:author><fr:author><fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link></fr:author><fr:author><fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link></fr:author></fr:authors><fr:meta name="bibtex"><![CDATA[@inproceedings{10.1145/3597503.3639099,
author = {Shi, Zheng and Mathur, Umang and Pavlogiannis, Andreas},
title = {Optimistic Prediction of Synchronization-Reversal Data Races},
year = {2024},
isbn = {9798400702174},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3597503.3639099},
doi = {10.1145/3597503.3639099},
abstract = {Dynamic data race detection has emerged as a key technique for ensuring reliability of concurrent software in practice. However, dynamic approaches can often miss data races owing to non-determinism in the thread scheduler. Predictive race detection techniques cater to this shortcoming by inferring alternate executions that may expose data races without re-executing the underlying program. More formally, the dynamic data race prediction problem asks, given a trace σ of an execution of a concurrent program, can σ be correctly reordered to expose a data race? Existing state-of-the art techniques for data race prediction either do not scale to executions arising from real world concurrent software, or only expose a limited class of data races, such as those that can be exposed without reversing the order of synchronization operations.In general, exposing data races by reasoning about synchronization reversals is an intractable problem. In this work, we identify a class of data races, called Optimistic Sync(hronization)-Reversal races that can be detected in a tractable manner and often include non-trivial data races that cannot be exposed by prior tractable techniques. We also propose a sound algorithm OSR for detecting all optimistic sync-reversal data races in overall quadratic time, and show that the algorithm is optimal by establishing a matching lower bound. Our experiments demonstrate the effectiveness of OSR--- on our extensive suite of benchmarks, OSR reports the largest number of data races, and scales well to large execution traces.},
booktitle = {Proceedings of the IEEE/ACM 46th International Conference on Software Engineering},
articleno = {134},
numpages = {13},
location = {Lisbon, Portugal},
series = {ICSE '24}
}]]></fr:meta><fr:meta name="doi">10.1145/3597503.3639099</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>327</fr:anchor><fr:addr type="user">farzan-mathur-grain-2024</fr:addr><fr:route>farzan-mathur-grain-2024.xml</fr:route><fr:title text="Coarser Equivalences for Causal Concurrency">Coarser Equivalences for Causal Concurrency</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month></fr:date><fr:authors><fr:author><fr:link type="local" href="azadehfarzan.xml" addr="azadehfarzan" title="Azadeh Farzan">Azadeh Farzan</fr:link></fr:author><fr:author><fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link></fr:author></fr:authors><fr:meta name="bibtex"><![CDATA[@article{10.1145/3632873,
author = {Farzan, Azadeh and Mathur, Umang},
title = {Coarser Equivalences for Causal Concurrency},
year = {2024},
issue_date = {January 2024},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {POPL},
url = {https://doi.org/10.1145/3632873},
doi = {10.1145/3632873},
abstract = {Trace theory (formulated by Mazurkiewicz in 1987) is a principled framework for defining equivalence relations for concurrent program runs based on a commutativity relation over the set of atomic steps taken by individual program threads. Its simplicity, elegance, and algorithmic efficiency makes it useful in many different contexts including program verification and testing. It is well-understood that the larger the equivalence classes are, the more benefits they would bring to the algorithms and applications that use them. In this paper, we study relaxations of trace equivalence with the goal of maintaining its algorithmic advantages. We first prove that the largest appropriate relaxation of trace equivalence, an equivalence relation that preserves the order of steps taken by each thread and what write operation each read operation observes, does not yield efficient algorithms. Specifically, we prove a linear space lower bound for the problem of checking, in a streaming setting, if two arbitrary steps of a concurrent program run are causally concurrent (i.e. they can be reordered in an equivalent run) or causally ordered (i.e. they always appear in the same order in all equivalent runs). The same problem can be decided in constant space for trace equivalence. Next, we propose a new commutativity-based notion of equivalence called grain equivalence that is strictly more relaxed than trace equivalence, and yet yields a constant space algorithm for the same problem. This notion of equivalence uses commutativity of grains, which are sequences of atomic steps, in addition to the standard commutativity from trace theory. We study the two distinct cases when the grains are contiguous subwords of the input program run and when they are not, formulate the precise definition of causal concurrency in each case, and show that they can be decided in constant space, despite being strict relaxations of the notion of causal concurrency based on trace equivalence.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {31},
numpages = {31},
keywords = {concurrency, equivalence, predictive analysis, reads-from, reduction}
}]]></fr:meta><fr:meta name="doi">10.1145/3632873</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>330</fr:anchor><fr:addr type="user">ang-mathur-pattern-2024</fr:addr><fr:route>ang-mathur-pattern-2024.xml</fr:route><fr:title text="Predictive Monitoring against Pattern Regular Languages">Predictive Monitoring against Pattern Regular Languages</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month></fr:date><fr:authors><fr:author><fr:link type="local" href="zhendongang.xml" addr="zhendongang" title="Zhendong Ang">Zhendong Ang</fr:link></fr:author><fr:author><fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link></fr:author></fr:authors><fr:meta name="bibtex"><![CDATA[@article{10.1145/3632915,
author = {Ang, Zhendong and Mathur, Umang},
title = {Predictive Monitoring against Pattern Regular Languages},
year = {2024},
issue_date = {January 2024},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {POPL},
url = {https://doi.org/10.1145/3632915},
doi = {10.1145/3632915},
abstract = {While current bug detection techniques for concurrent software focus on unearthing low-level issues such as data races or deadlocks, they often fall short of discovering more intricate temporal behaviours that can arise even in the absence of such low-level issues. In this paper, we focus on the problem of dynamically analysing concurrent software against high-level temporal specifications such as LTL. Existing techniques for runtime monitoring against such specifications are primarily designed for sequential software and remain inadequate in the presence of concurrency — violations may be observed only in intricate thread interleavings, requiring many re-runs of the underlying software in conjunction with the analysis. Towards this, we study the problem of predictive runtime monitoring, inspired by the analogous problem of predictive data race detection studied extensively recently. The predictive runtime monitoring question asks, given an execution σ, if it can be soundly reordered to expose violations of a specification. In general, this problem may become easily intractable when either the specifications or the notion of reorderings used is complex. In this paper, we focus on specifications that are given in regular languages. Our notion of reorderings is trace equivalence, where an execution is considered a reordering of another if it can be obtained from the latter by successively commuting adjacent independent actions. We first show that, even in this simplistic setting, the problem of predictive monitoring admits a super-linear lower bound of O(nα), where n is the number of events in the execution, and α is a parameter describing the degree of commutativity, and typically corresponds to the number of threads in the execution. As a result, predictive runtime monitoring even in this setting is unlikely to be efficiently solvable, unlike in the non-predictive setting where the problem can be checked using a deterministic finite automaton (and thus, a constant-space streaming linear-time algorithm). Towards this, we identify a sub-class of regular languages, called pattern languages (and their extension generalized pattern languages). Pattern languages can naturally express specific ordering of some number of (labelled) events, and have been inspired by popular empirical hypotheses underlying many concurrency bug detection approaches such as the “small bug depth” hypothesis. More importantly, we show that for pattern (and generalized pattern) languages, the predictive monitoring problem can be solved using a constant-space streaming linear-time algorithm. We implement and evaluate our algorithm PatternTrack on benchmarks from the literature and show that it is effective in monitoring large-scale applications.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {73},
numpages = {35},
keywords = {complexity, concurrency, dynamic analysis, predictive monitoring}
}]]></fr:meta><fr:meta name="doi">10.1145/3632915</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>333</fr:anchor><fr:addr type="user">mathur-pavlogiannis-viswanathan-syncp-2021</fr:addr><fr:route>mathur-pavlogiannis-viswanathan-syncp-2021.xml</fr:route><fr:title text="Optimal prediction of synchronization-preserving races">Optimal prediction of synchronization-preserving races</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2021</fr:year><fr:month>1</fr:month></fr:date><fr:authors><fr:author><fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link></fr:author><fr:author><fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link></fr:author><fr:author><fr:link type="local" href="maheshviswanathan.xml" addr="maheshviswanathan" title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link></fr:author></fr:authors><fr:meta name="bibtex"><![CDATA[@article{10.1145/3434317,
author = {Mathur, Umang and Pavlogiannis, Andreas and Viswanathan, Mahesh},
title = {Optimal prediction of synchronization-preserving races},
year = {2021},
issue_date = {January 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {POPL},
url = {https://doi.org/10.1145/3434317},
doi = {10.1145/3434317},
abstract = {Concurrent programs are notoriously hard to write correctly, as scheduling nondeterminism introduces subtle errors that are both hard to detect and to reproduce. The most common concurrency errors are (data) races, which occur when memory-conflicting actions are executed concurrently. Consequently, considerable effort has been made towards developing efficient techniques for race detection. The most common approach is dynamic race prediction: given an observed, race-free trace σ of a concurrent program, the task is to decide whether events of σ can be correctly reordered to a trace σ* that witnesses a race hidden in σ. In this work we introduce the notion of sync(hronization)-preserving races. A sync-preserving race occurs in σ when there is a witness σ* in which synchronization operations (e.g., acquisition and release of locks) appear in the same order as in σ. This is a broad definition that strictly subsumes the famous notion of happens-before races. Our main results are as follows. First, we develop a sound and complete algorithm for predicting sync-preserving races. For moderate values of parameters like the number of threads, the algorithm runs in \~{O}(N) time and space, where N is the length of the trace σ. Second, we show that the problem has a Ω(N/log2 N) space lower bound, and thus our algorithm is essentially time and space optimal. Third, we show that predicting races with even just a single reversal of two sync operations is NP-complete and even W1-hard when parameterized by the number of threads. Thus, sync-preservation characterizes exactly the tractability boundary of race prediction, and our algorithm is nearly optimal for the tractable side. Our experiments show that our algorithm is fast in practice, while sync-preservation characterizes races often missed by state-of-the-art methods.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {36},
numpages = {29},
keywords = {race detection, dynamic analysis, concurrency, complexity}
}]]></fr:meta><fr:meta name="doi">10.1145/3434317</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>337</fr:anchor><fr:addr type="user">mathur-pavlogiannis-viswanathan-2020</fr:addr><fr:route>mathur-pavlogiannis-viswanathan-2020.xml</fr:route><fr:title text="The Complexity of Dynamic Data Race Prediction">The Complexity of Dynamic Data Race Prediction</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2020</fr:year><fr:month>7</fr:month></fr:date><fr:authors><fr:author><fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link></fr:author><fr:author><fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link></fr:author><fr:author><fr:link type="local" href="maheshviswanathan.xml" addr="maheshviswanathan" title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link></fr:author></fr:authors><fr:meta name="bibtex"><![CDATA[@inproceedings{10.1145/3373718.3394783,
author = {Mathur, Umang and Pavlogiannis, Andreas and Viswanathan, Mahesh},
title = {The Complexity of Dynamic Data Race Prediction},
year = {2020},
isbn = {9781450371049},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3373718.3394783},
doi = {10.1145/3373718.3394783},
abstract = {Writing concurrent programs is notoriously hard due to scheduling non-determinism. The most common concurrency bugs are data races, which are accesses to a shared resource that can be executed concurrently. Dynamic data-race prediction is the most standard technique for detecting data races: given an observed, data-race-free trace t, the task is to determine whether t can be reordered to a trace t* that exposes a data-race. Although the problem has received significant practical attention for over three decades, its complexity has remained elusive. In this work, we address this lacuna, identifying sources of intractability and conditions under which the problem is efficiently solvable. Given a trace t of size n over k threads, our main results are as follows.First, we establish a general O(k · n2·(k-1) upper-bound, as well as an O(nk) upper-bound when certain parameters of t are constant. In addition, we show that the problem is NP-hard and even W[1]-hard parameterized by k, and thus unlikely to be fixed-parameter tractable. Second, we study the problem over acyclic communication topologies, such as server-clients hierarchies. We establish an O(k2 · d · n2 · log n) upper-bound, where d is the number of shared variables accessed in t. In addition, we show that even for traces with k = 2 threads, the problem has no O(n2-ϵ) algorithm under the Orthogonal Vectors conjecture. Since any trace with 2 threads defines an acyclic topology, our upper-bound for this case is optimal up to polynomial improvements for up to moderate values of k and d. Finally, motivated by existing heuristics, we study a distance-bounded version of the problem, where the task is to expose a data race by a witness trace that is similar to t. We develop an algorithm that works in O(n) time when certain parameters of t are constant.},
booktitle = {Proceedings of the 35th Annual ACM/IEEE Symposium on Logic in Computer Science},
pages = {713–727},
numpages = {15},
keywords = {Complexity, Data Race Prediction},
location = {Saarbr\"{u}cken, Germany},
series = {LICS '20}
}]]></fr:meta><fr:meta name="doi">10.1145/3373718.3394783</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>341</fr:anchor><fr:addr type="user">pavlogiannis-m2-2019</fr:addr><fr:route>pavlogiannis-m2-2019.xml</fr:route><fr:title text="Fast, sound, and effectively complete dynamic race prediction">Fast, sound, and effectively complete dynamic race prediction</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2019</fr:year><fr:month>12</fr:month></fr:date><fr:authors><fr:author><fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link></fr:author></fr:authors><fr:meta name="bibtex"><![CDATA[@article{10.1145/3371085,
author = {Pavlogiannis, Andreas},
title = {Fast, sound, and effectively complete dynamic race prediction},
year = {2019},
issue_date = {January 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {POPL},
url = {https://doi.org/10.1145/3371085},
doi = {10.1145/3371085},
abstract = {Writing concurrent programs is highly error-prone due to the nondeterminism in interprocess communication. The most reliable indicators of errors in concurrency are data races, which are accesses to a shared resource that can be executed concurrently. We study the problem of predicting data races in lock-based concurrent programs. The input consists of a concurrent trace t, and the task is to determine all pairs of events of t that constitute a data race. The problem lies at the heart of concurrent verification and has been extensively studied for over three decades. However, existing polynomial-time sound techniques are highly incomplete and can miss simple races. In this work we develop M2: a new polynomial-time algorithm for this problem, which has no false positives. In addition, our algorithm is complete for input traces that consist of two processes, i.e., it provably detects all races in the trace. We also develop sufficient criteria for detecting completeness dynamically in cases of more than two processes. We make an experimental evaluation of our algorithm on a challenging set of benchmarks taken from recent literature on the topic. Our algorithm soundly reports hundreds of real races, many of which are missed by existing methods. In addition, using our dynamic completeness criteria, M2 concludes that it has detected all races in the benchmark set, hence the reports are both sound and complete. Finally, its running times are comparable, and often smaller than the theoretically fastest, yet highly incomplete, existing methods. To our knowledge, M2 is the first sound algorithm that achieves such a level of performance on both running time and completeness of the reported races.},
journal = {Proc. ACM Program. Lang.},
month = {dec},
articleno = {17},
numpages = {29},
keywords = {race detection, predictive analyses, concurrency}
}]]></fr:meta><fr:meta name="doi">10.1145/3371085</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>343</fr:anchor><fr:addr type="user">mathur-kini-viswanathan-shb-2018</fr:addr><fr:route>mathur-kini-viswanathan-shb-2018.xml</fr:route><fr:title text="What happens-after the first race? Enhancing the predictive power of happens-before based dynamic race detection">What happens-after the first race? Enhancing the predictive power of happens-before based dynamic race detection</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2018</fr:year><fr:month>10</fr:month></fr:date><fr:authors><fr:author><fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link></fr:author><fr:author>Dileep Kini</fr:author><fr:author><fr:link type="local" href="maheshviswanathan.xml" addr="maheshviswanathan" title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link></fr:author></fr:authors><fr:meta name="bibtex"><![CDATA[@article{10.1145/3276515,
author = {Mathur, Umang and Kini, Dileep and Viswanathan, Mahesh},
title = {What happens-after the first race? enhancing the predictive power of happens-before based dynamic race detection},
year = {2018},
issue_date = {November 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {OOPSLA},
url = {https://doi.org/10.1145/3276515},
doi = {10.1145/3276515},
abstract = {Dynamic race detection is the problem of determining if an observed program execution reveals the presence of a data race in a program. The classical approach to solving this problem is to detect if there is a pair of conflicting memory accesses that are unordered by Lamport’s happens-before (HB) relation. HB based race detection is known to not report false positives, i.e., it is sound. However, the soundness guarantee of HB only promises that the first pair of unordered, conflicting events is a schedulable data race. That is, there can be pairs of HB-unordered conflicting data accesses that are not schedulable races because there is no reordering of the events of the execution, where the events in race can be executed immediately after each other. We introduce a new partial order, called schedulable happens-before (SHB) that exactly characterizes the pairs of schedulable data races — every pair of conflicting data accesses that are identified by SHB can be scheduled, and every HB-race that can be scheduled is identified by SHB. Thus, the SHB partial order is truly sound. We present a linear time, vector clock algorithm to detect schedulable races using SHB. Our experiments demonstrate the value of our algorithm for dynamic race detection — SHB incurs only little performance overhead and can scale to executions from real-world software applications without compromising soundness.},
journal = {Proc. ACM Program. Lang.},
month = {oct},
articleno = {145},
numpages = {29},
keywords = {Concurrency, Dynamic Program Analysis, Happens-Before, Race Detection, Soundness}
}]]></fr:meta><fr:meta name="doi">10.1145/3276515</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>347</fr:anchor><fr:addr type="user">kini-mathur-viswanathan-wcp-2017</fr:addr><fr:route>kini-mathur-viswanathan-wcp-2017.xml</fr:route><fr:title text="Dynamic race prediction in linear time">Dynamic race prediction in linear time</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2017</fr:year><fr:month>6</fr:month></fr:date><fr:authors><fr:author>Dileep Kini</fr:author><fr:author><fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link></fr:author><fr:author><fr:link type="local" href="maheshviswanathan.xml" addr="maheshviswanathan" title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link></fr:author></fr:authors><fr:meta name="bibtex"><![CDATA[@inproceedings{10.1145/3062341.3062374,
author = {Kini, Dileep and Mathur, Umang and Viswanathan, Mahesh},
title = {Dynamic race prediction in linear time},
year = {2017},
isbn = {9781450349888},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3062341.3062374},
doi = {10.1145/3062341.3062374},
abstract = {Writing reliable concurrent software remains a huge challenge for today's programmers. Programmers rarely reason about their code by explicitly considering different possible inter-leavings of its execution. We consider the problem of detecting data races from individual executions in a sound manner. The classical approach to solving this problem has been to use Lamport's happens-before (HB) relation. Until now HB remains the only approach that runs in linear time. Previous efforts in improving over HB such as causally-precedes (CP) and maximal causal models fall short due to the fact that they are not implementable efficiently and hence have to compromise on their race detecting ability by limiting their techniques to bounded sized fragments of the execution. We present a new relation weak-causally-precedes (WCP) that is provably better than CP in terms of being able to detect more races, while still remaining sound. Moreover, it admits a linear time algorithm which works on the entire execution without having to fragment it.},
booktitle = {Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {157–170},
numpages = {14},
keywords = {Race Prediction, Online Algorithm, Concurrency},
location = {Barcelona, Spain},
series = {PLDI 2017}
}

@article{10.1145/3140587.3062374,
author = {Kini, Dileep and Mathur, Umang and Viswanathan, Mahesh},
title = {Dynamic race prediction in linear time},
year = {2017},
issue_date = {June 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/3140587.3062374},
doi = {10.1145/3140587.3062374},
abstract = {Writing reliable concurrent software remains a huge challenge for today's programmers. Programmers rarely reason about their code by explicitly considering different possible inter-leavings of its execution. We consider the problem of detecting data races from individual executions in a sound manner. The classical approach to solving this problem has been to use Lamport's happens-before (HB) relation. Until now HB remains the only approach that runs in linear time. Previous efforts in improving over HB such as causally-precedes (CP) and maximal causal models fall short due to the fact that they are not implementable efficiently and hence have to compromise on their race detecting ability by limiting their techniques to bounded sized fragments of the execution. We present a new relation weak-causally-precedes (WCP) that is provably better than CP in terms of being able to detect more races, while still remaining sound. Moreover, it admits a linear time algorithm which works on the entire execution without having to fragment it.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {157–170},
numpages = {14},
keywords = {Race Prediction, Online Algorithm, Concurrency}
}]]></fr:meta><fr:meta name="doi">10.1145/3062341.3062374</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>351</fr:anchor><fr:addr type="user">huang-meredith-rosu-rvpredict-2014</fr:addr><fr:route>huang-meredith-rosu-rvpredict-2014.xml</fr:route><fr:title text="Maximal sound predictive race detection with control flow abstraction">Maximal sound predictive race detection with control flow abstraction</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2014</fr:year><fr:month>6</fr:month></fr:date><fr:authors><fr:author>Jeff Huang</fr:author><fr:author>Patrick O’Neil Meredith</fr:author><fr:author><fr:link type="local" href="grigorerosu.xml" addr="grigorerosu" title="Grigore Rosu">Grigore Rosu</fr:link></fr:author></fr:authors><fr:meta name="bibtex"><![CDATA[@inproceedings{10.1145/2594291.2594315,
author = {Huang, Jeff and Meredith, Patrick O'Neil and Rosu, Grigore},
title = {Maximal sound predictive race detection with control flow abstraction},
year = {2014},
isbn = {9781450327848},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2594291.2594315},
doi = {10.1145/2594291.2594315},
abstract = {Despite the numerous static and dynamic program analysis techniques in the literature, data races remain one of the most common bugs in modern concurrent software. Further, the techniques that do exist either have limited detection capability or are unsound, meaning that they report false positives. We present a sound race detection technique that achieves a provably higher detection capability than existing sound techniques. A key insight of our technique is the inclusion of abstracted control flow information into the execution model, which increases the space of the causal model permitted by classical happens-before or causally-precedes based detectors. By encoding the control flow and a minimal set of feasibility constraints as a group of first-order logic formulae, we formulate race detection as a constraint solving problem. Moreover, we formally prove that our formulation achieves the maximal possible detection capability for any sound dynamic race detector with respect to the same input trace under the sequential consistency memory model. We demonstrate via extensive experimentation that our technique detects more races than the other state-of-the-art sound race detection techniques, and that it is scalable to executions of real world concurrent applications with tens of millions of critical events. These experiments also revealed several previously unknown races in real systems (e.g., Eclipse) that have been confirmed or fixed by the developers. Our tool is also adopted by Eclipse developers.},
booktitle = {Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {337–348},
numpages = {12},
keywords = {control flow, data race, maximal sound, prediction},
location = {Edinburgh, United Kingdom},
series = {PLDI '14}
}

@article{10.1145/2666356.2594315,
author = {Huang, Jeff and Meredith, Patrick O'Neil and Rosu, Grigore},
title = {Maximal sound predictive race detection with control flow abstraction},
year = {2014},
issue_date = {June 2014},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {49},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/2666356.2594315},
doi = {10.1145/2666356.2594315},
abstract = {Despite the numerous static and dynamic program analysis techniques in the literature, data races remain one of the most common bugs in modern concurrent software. Further, the techniques that do exist either have limited detection capability or are unsound, meaning that they report false positives. We present a sound race detection technique that achieves a provably higher detection capability than existing sound techniques. A key insight of our technique is the inclusion of abstracted control flow information into the execution model, which increases the space of the causal model permitted by classical happens-before or causally-precedes based detectors. By encoding the control flow and a minimal set of feasibility constraints as a group of first-order logic formulae, we formulate race detection as a constraint solving problem. Moreover, we formally prove that our formulation achieves the maximal possible detection capability for any sound dynamic race detector with respect to the same input trace under the sequential consistency memory model. We demonstrate via extensive experimentation that our technique detects more races than the other state-of-the-art sound race detection techniques, and that it is scalable to executions of real world concurrent applications with tens of millions of critical events. These experiments also revealed several previously unknown races in real systems (e.g., Eclipse) that have been confirmed or fixed by the developers. Our tool is also adopted by Eclipse developers.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {337–348},
numpages = {12},
keywords = {control flow, data race, maximal sound, prediction}
}]]></fr:meta><fr:meta name="doi">10.1145/2594291.2594315</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>355</fr:anchor><fr:addr type="user">smaragdakis-cp-2012</fr:addr><fr:route>smaragdakis-cp-2012.xml</fr:route><fr:title text="Sound predictive race detection in polynomial time">Sound predictive race detection in polynomial time</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2012</fr:year><fr:month>1</fr:month></fr:date><fr:authors><fr:author>Yannis Smaragdakis</fr:author><fr:author>Jacob M. Evans</fr:author><fr:author>Caitlin Sadowski</fr:author><fr:author>Jaeheon Yi</fr:author><fr:author>Cormac Flanagan</fr:author></fr:authors><fr:meta name="bibtex"><![CDATA[@inproceedings{10.1145/2103656.2103702,
author = {Smaragdakis, Yannis and Evans, Jacob and Sadowski, Caitlin and Yi, Jaeheon and Flanagan, Cormac},
title = {Sound predictive race detection in polynomial time},
year = {2012},
isbn = {9781450310833},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2103656.2103702},
doi = {10.1145/2103656.2103702},
abstract = {Data races are among the most reliable indicators of programming errors in concurrent software. For at least two decades, Lamport's happens-before (HB) relation has served as the standard test for detecting races--other techniques, such as lockset-based approaches, fail to be sound, as they may falsely warn of races. This work introduces a new relation, causally-precedes (CP), which generalizes happens-before to observe more races without sacrificing soundness. Intuitively, CP tries to capture the concept of happens-before ordered events that must occur in the observed order for the program to observe the same values. What distinguishes CP from past predictive race detection approaches (which also generalize an observed execution to detect races in other plausible executions) is that CP-based race detection is both sound and of polynomial complexity. We demonstrate that the unique aspects of CP result in practical benefit. Applying CP to real-world programs, we successfully analyze server-level applications (e.g., Apache FtpServer) and show that traces longer than in past predictive race analyses can be analyzed in mere seconds to a few minutes. For these programs, CP race detection uncovers races that are hard to detect by repeated execution and HB race detection: a single run of CP race detection produces several races not discovered by 10 separate rounds of happens-before race detection.},
booktitle = {Proceedings of the 39th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {387–400},
numpages = {14},
keywords = {dynamic analysis, happens-before, race detection},
location = {Philadelphia, PA, USA},
series = {POPL '12}
}

@article{10.1145/2103621.2103702,
author = {Smaragdakis, Yannis and Evans, Jacob and Sadowski, Caitlin and Yi, Jaeheon and Flanagan, Cormac},
title = {Sound predictive race detection in polynomial time},
year = {2012},
issue_date = {January 2012},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {47},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/2103621.2103702},
doi = {10.1145/2103621.2103702},
abstract = {Data races are among the most reliable indicators of programming errors in concurrent software. For at least two decades, Lamport's happens-before (HB) relation has served as the standard test for detecting races--other techniques, such as lockset-based approaches, fail to be sound, as they may falsely warn of races. This work introduces a new relation, causally-precedes (CP), which generalizes happens-before to observe more races without sacrificing soundness. Intuitively, CP tries to capture the concept of happens-before ordered events that must occur in the observed order for the program to observe the same values. What distinguishes CP from past predictive race detection approaches (which also generalize an observed execution to detect races in other plausible executions) is that CP-based race detection is both sound and of polynomial complexity. We demonstrate that the unique aspects of CP result in practical benefit. Applying CP to real-world programs, we successfully analyze server-level applications (e.g., Apache FtpServer) and show that traces longer than in past predictive race analyses can be analyzed in mere seconds to a few minutes. For these programs, CP race detection uncovers races that are hard to detect by repeated execution and HB race detection: a single run of CP race detection produces several races not discovered by 10 separate rounds of happens-before race detection.},
journal = {SIGPLAN Not.},
month = {jan},
pages = {387–400},
numpages = {14},
keywords = {dynamic analysis, happens-before, race detection}
}]]></fr:meta><fr:meta name="doi">10.1145/2103656.2103702</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>361</fr:anchor><fr:addr type="user">mazurkiewicz-trace-1986</fr:addr><fr:route>mazurkiewicz-trace-1986.xml</fr:route><fr:title text="Trace Theory">Trace Theory</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>1987</fr:year></fr:date><fr:authors><fr:author>Antoni Mazurkiewicz</fr:author></fr:authors><fr:meta name="bibtex"><![CDATA[@InProceedings{10.1007/3-540-17906-2_30,
author="Mazurkiewicz, Antoni",
editor="Brauer, W.
and Reisig, W.
and Rozenberg, G.",
title="Trace theory",
booktitle="Petri Nets: Applications and Relationships to Other Models of Concurrency",
year="1987",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="278--324",
abstract="The concept of traces has been introduced for describing non-sequential behaviour of concurrent systems via its sequential observations. Traces represent concurrent processes in the same way as strings represent sequential ones. The theory of traces can be used as a tool for reasoning about nets and it is hoped that applying this theory one can get a calculus of the concurrent processes anologous to that available for sequential systems. The following topics will be discussed: algebraic properties of traces, trace models of some concurrency phenomena, fixed-point calculus for finding the behaviour of nets, modularity, and some applications of the presented theory.",
isbn="978-3-540-47926-0"
}]]></fr:meta><fr:meta name="doi">10.1007/3-540-17906-2_30</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>363</fr:anchor><fr:addr type="user">lamport-clocks-1978</fr:addr><fr:route>lamport-clocks-1978.xml</fr:route><fr:title text="Time, clocks, and the ordering of events in a distributed system">Time, clocks, and the ordering of events in a distributed system</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>1978</fr:year><fr:month>7</fr:month></fr:date><fr:authors><fr:author>Leslie Lamport</fr:author></fr:authors><fr:meta name="bibtex"><![CDATA[@article{10.1145/359545.359563,
author = {Lamport, Leslie},
title = {Time, clocks, and the ordering of events in a distributed system},
year = {1978},
issue_date = {July 1978},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {21},
number = {7},
issn = {0001-0782},
url = {https://doi.org/10.1145/359545.359563},
doi = {10.1145/359545.359563},
abstract = {The concept of one event happening before another in a distributed system is examined, and is shown to define a partial ordering of the events. A distributed algorithm is given for synchronizing a system of logical clocks which can be used to totally order the events. The use of the total ordering is illustrated with a method for solving synchronization problems. The algorithm is then specialized for synchronizing physical clocks, and a bound is derived on how far out of synchrony the clocks can become.},
journal = {Commun. ACM},
month = {jul},
pages = {558–565},
numpages = {8},
keywords = {multiprocess systems, distributed systems, computer networks, clock synchronization}
}]]></fr:meta><fr:meta name="doi">10.1145/359545.359563</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree>


  <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>365</fr:anchor><fr:addr type="machine">#248</fr:addr><fr:route>unstable-248.xml</fr:route><fr:title text="Talks">Talks</fr:title><fr:authors><fr:author><fr:link type="local" href="daniellimws.xml" addr="daniellimws" title="Daniel Lim Wee Soong">Daniel Lim Wee Soong</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>367</fr:anchor><fr:addr type="user">farzan-grain-2024-iarcs</fr:addr><fr:route>farzan-grain-2024-iarcs.xml</fr:route><fr:title text="Coarser Equivalences for Causal Concurrency">Coarser Equivalences for Causal Concurrency</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month></fr:date><fr:authors><fr:author><fr:link type="local" href="azadehfarzan.xml" addr="azadehfarzan" title="Azadeh Farzan">Azadeh Farzan</fr:link></fr:author></fr:authors><fr:meta name="external">https://www.youtube.com/watch?v=hYJv7Pf53yU</fr:meta><fr:meta name="venue">IARCS Verification Seminar</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>369</fr:anchor><fr:addr type="user">mathur-pavlogiannis-2021-asplos</fr:addr><fr:route>mathur-pavlogiannis-2021-asplos.xml</fr:route><fr:title text="Dynamic Data-Race Prediction : Fundamentals, Theory and Practice">Dynamic Data-Race Prediction : Fundamentals, Theory and Practice</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2021</fr:year><fr:month>4</fr:month></fr:date><fr:authors><fr:author><fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link></fr:author><fr:author><fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link></fr:author></fr:authors><fr:meta name="external">https://www.youtube.com/watch?v=B6q2NQ5Tp2I</fr:meta><fr:meta name="venue">ASPLOS 2021 Tutorial</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Data races are arguably the most insidious amongst concurrency bugs and extensive research efforts have been dedicated to effectively detect them. Predictive race detection techniques aim to expose data races missed by traditional dynamic race detectors (such as those based on Happens-Before) by inferring data races in alternate executions of the underlying program, without re-executing it. The resulting promise of enhanced coverage in race detection has recently led to the development of many dynamic race prediction techniques.</fr:p><fr:p>This tutorial aims to present the foundations of race prediction in a principled manner, consolidate a decade long line of work on dynamic race prediction and discusses recent algorithmic advances that make race prediction efficient and practical. This tutorial also aims to discuss some recent results on the complexity and hardness involved in reasoning about race prediction.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>372</fr:anchor><fr:addr type="user">mathur-pavlogiannis-2021-popl</fr:addr><fr:route>mathur-pavlogiannis-2021-popl.xml</fr:route><fr:title text="Dynamic Data-Race Prediction: Fundamentals, Theory and Practice">Dynamic Data-Race Prediction: Fundamentals, Theory and Practice</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2021</fr:year><fr:month>1</fr:month></fr:date><fr:authors><fr:author><fr:link type="local" href="umangmathur.xml" addr="umangmathur" title="Umang Mathur">Umang Mathur</fr:link></fr:author><fr:author><fr:link type="local" href="andreaspavlogiannis.xml" addr="andreaspavlogiannis" title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link></fr:author></fr:authors><fr:meta name="external">https://www.youtube.com/watch?v=5AZIQFeluIY</fr:meta><fr:meta name="venue">POPL 2021 Tutorial</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Till date, concurrency bugs inevitably find their way into concurrent software despite rigorous development-time testing. Data races are arguably the most insidious amongst concurrency bugs and are particularly hard to detect.</fr:p><fr:p>This tutorial focuses on recent developments in dynamic analysis techniques for detecting data races. Traditional dynamic race detection techniques, such as those based on Lamport’s happens-before (HB) partial order, are ineffective in exposing races that get ordered due to inexplicit synchronization, but can nevertheless be witnessed in alternate executions of the same underlying program. Predictive race detection techniques, on the other hand, aim to overcome this shortcoming of traditional dynamic race detectors by expose data races that can be missed by HB, without requiring a re-execution of the underlying program. The resulting promise of enhanced coverage in race detection has recently led to the development of many dynamic race prediction techniques.</fr:p><fr:p>In this tutorial we will discuss some of the state-of-the-art algorithms and techniques for dynamic data race prediction, present the foundations of race prediction in a principled manner and discuss some recent investigations on the complexity and hardness involved in reasoning about race prediction.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree>

  <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>375</fr:anchor><fr:addr type="machine">#249</fr:addr><fr:route>unstable-249.xml</fr:route><fr:title text="Dissertations">Dissertations</fr:title><fr:authors><fr:author><fr:link type="local" href="daniellimws.xml" addr="daniellimws" title="Daniel Lim Wee Soong">Daniel Lim Wee Soong</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:info>Query returned no results</fr:info></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

  <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>377</fr:anchor><fr:addr type="machine">#250</fr:addr><fr:route>unstable-250.xml</fr:route><fr:title text="People">People</fr:title><fr:authors><fr:author><fr:link type="local" href="daniellimws.xml" addr="daniellimws" title="Daniel Lim Wee Soong">Daniel Lim Wee Soong</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>379</fr:anchor><fr:addr type="user">andreaspavlogiannis</fr:addr><fr:route>andreaspavlogiannis.xml</fr:route><fr:title text="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:title><fr:taxon>Person</fr:taxon><fr:authors /><fr:meta name="external">https://pure.au.dk/portal/en/persons/pavlogiannis@cs.au.dk</fr:meta><fr:meta name="institution"><fr:link type="local" href="aarhus.xml" addr="aarhus" title="Aarhus University">Aarhus University</fr:link></fr:meta><fr:meta name="orcid">0000-0002-8943-0722</fr:meta><fr:meta name="position">Associate Professor</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Associate Professor at Aarhus University.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>380</fr:anchor><fr:addr type="user">azadehfarzan</fr:addr><fr:route>azadehfarzan.xml</fr:route><fr:title text="Azadeh Farzan">Azadeh Farzan</fr:title><fr:taxon>Person</fr:taxon><fr:authors /><fr:meta name="external">https://www.cs.toronto.edu/~azadeh/index.html</fr:meta><fr:meta name="institution"><fr:link type="local" href="uoft.xml" addr="uoft" title="University of Toronto">University of Toronto</fr:link></fr:meta><fr:meta name="orcid">0000-0001-9005-2653</fr:meta><fr:meta name="position">Professor</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Professor at University of Toronto.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>381</fr:anchor><fr:addr type="user">grigorerosu</fr:addr><fr:route>grigorerosu.xml</fr:route><fr:title text="Grigore Rosu">Grigore Rosu</fr:title><fr:taxon>Person</fr:taxon><fr:authors /><fr:meta name="external">https://fsl.cs.illinois.edu/people/grigore-rosu/</fr:meta><fr:meta name="institution"><fr:link type="local" href="uiuc.xml" addr="uiuc" title="University of Illinois at Urbana-Champaign, USA">University of Illinois at Urbana-Champaign, USA</fr:link></fr:meta><fr:meta name="orcid">0000-0002-3102-0421</fr:meta><fr:meta name="position">Professor</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Professor of Computer Science at University of Illinois at Urbana-Champaign.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>382</fr:anchor><fr:addr type="user">maheshviswanathan</fr:addr><fr:route>maheshviswanathan.xml</fr:route><fr:title text="Mahesh Viswanathan">Mahesh Viswanathan</fr:title><fr:taxon>Person</fr:taxon><fr:authors /><fr:meta name="external">https://vmahesh.cs.illinois.edu/</fr:meta><fr:meta name="institution"><fr:link type="local" href="uiuc.xml" addr="uiuc" title="University of Illinois at Urbana-Champaign, USA">University of Illinois at Urbana-Champaign, USA</fr:link></fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>383</fr:anchor><fr:addr type="user">umangmathur</fr:addr><fr:route>umangmathur.xml</fr:route><fr:title text="Umang Mathur">Umang Mathur</fr:title><fr:taxon>Person</fr:taxon><fr:authors /><fr:meta name="external">https://www.comp.nus.edu.sg/~umathur/</fr:meta><fr:meta name="institution"><fr:link type="local" href="nus.xml" addr="nus" title="National University of Singapore">National University of Singapore</fr:link></fr:meta><fr:meta name="orcid">0000-0002-7610-0660</fr:meta><fr:meta name="position">Assistant Professor</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Assistant Professor in Programming Languages &amp; Software Engineering at the National University of Singapore.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>384</fr:anchor><fr:addr type="user">zhendongang</fr:addr><fr:route>zhendongang.xml</fr:route><fr:title text="Zhendong Ang">Zhendong Ang</fr:title><fr:taxon>Person</fr:taxon><fr:authors /><fr:meta name="external">https://ang9876.github.io/</fr:meta><fr:meta name="institution"><fr:link type="local" href="nus.xml" addr="nus" title="National University of Singapore">National University of Singapore</fr:link></fr:meta><fr:meta name="orcid">0009-0002-0214-3462</fr:meta><fr:meta name="position">PhD</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>PhD student in Programming Languages &amp; Software Engineering at the National University of Singapore.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>385</fr:anchor><fr:addr type="user">zhengshi</fr:addr><fr:route>zhengshi.xml</fr:route><fr:title text="Zheng Shi">Zheng Shi</fr:title><fr:taxon>Person</fr:taxon><fr:authors /><fr:meta name="external">https://www.comp.nus.edu.sg/~zs357/</fr:meta><fr:meta name="institution"><fr:link type="local" href="nus.xml" addr="nus" title="National University of Singapore">National University of Singapore</fr:link></fr:meta><fr:meta name="orcid">0000-0001-5021-7134</fr:meta><fr:meta name="position">PhD</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>PhD student in Programming Languages &amp; Software Engineering at the National University of Singapore.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter>
          <fr:backmatter />
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
