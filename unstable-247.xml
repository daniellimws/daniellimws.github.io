<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>651</fr:anchor><fr:addr
type="machine">#247</fr:addr><fr:route>unstable-247.xml</fr:route><fr:title
text="Race prediction › talks"><fr:link
type="local"
href="dlws-0004.xml"
addr="dlws-0004"
title="Race prediction">Race prediction</fr:link> › talks</fr:title><fr:authors><fr:author><fr:link
type="local"
href="daniellimws.xml"
addr="daniellimws"
title="Daniel Lim Wee Soong">Daniel Lim Wee Soong</fr:link></fr:author></fr:authors><fr:parent>dlws-0004</fr:parent></fr:frontmatter><fr:mainmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>323</fr:anchor><fr:addr
type="user">farzan-grain-2024-iarcs</fr:addr><fr:route>farzan-grain-2024-iarcs.xml</fr:route><fr:title
text="Coarser Equivalences for Causal Concurrency">Coarser Equivalences for Causal Concurrency</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month></fr:date><fr:authors><fr:author><fr:link
type="local"
href="azadehfarzan.xml"
addr="azadehfarzan"
title="Azadeh Farzan">Azadeh Farzan</fr:link></fr:author></fr:authors><fr:meta
name="external">https://www.youtube.com/watch?v=hYJv7Pf53yU</fr:meta><fr:meta
name="venue">IARCS Verification Seminar</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>325</fr:anchor><fr:addr
type="user">mathur-pavlogiannis-2021-asplos</fr:addr><fr:route>mathur-pavlogiannis-2021-asplos.xml</fr:route><fr:title
text="Dynamic Data-Race Prediction : Fundamentals, Theory and Practice">Dynamic Data-Race Prediction : Fundamentals, Theory and Practice</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2021</fr:year><fr:month>4</fr:month></fr:date><fr:authors><fr:author><fr:link
type="local"
href="umangmathur.xml"
addr="umangmathur"
title="Umang Mathur">Umang Mathur</fr:link></fr:author><fr:author><fr:link
type="local"
href="andreaspavlogiannis.xml"
addr="andreaspavlogiannis"
title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link></fr:author></fr:authors><fr:meta
name="external">https://www.youtube.com/watch?v=B6q2NQ5Tp2I</fr:meta><fr:meta
name="venue">ASPLOS 2021 Tutorial</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Data races are arguably the most insidious amongst concurrency bugs and extensive research efforts have been dedicated to effectively detect them. Predictive race detection techniques aim to expose data races missed by traditional dynamic race detectors (such as those based on Happens-Before) by inferring data races in alternate executions of the underlying program, without re-executing it. The resulting promise of enhanced coverage in race detection has recently led to the development of many dynamic race prediction techniques.</fr:p><fr:p>This tutorial aims to present the foundations of race prediction in a principled manner, consolidate a decade long line of work on dynamic race prediction and discusses recent algorithmic advances that make race prediction efficient and practical. This tutorial also aims to discuss some recent results on the complexity and hardness involved in reasoning about race prediction.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>328</fr:anchor><fr:addr
type="user">mathur-pavlogiannis-2021-popl</fr:addr><fr:route>mathur-pavlogiannis-2021-popl.xml</fr:route><fr:title
text="Dynamic Data-Race Prediction: Fundamentals, Theory and Practice">Dynamic Data-Race Prediction: Fundamentals, Theory and Practice</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2021</fr:year><fr:month>1</fr:month></fr:date><fr:authors><fr:author><fr:link
type="local"
href="umangmathur.xml"
addr="umangmathur"
title="Umang Mathur">Umang Mathur</fr:link></fr:author><fr:author><fr:link
type="local"
href="andreaspavlogiannis.xml"
addr="andreaspavlogiannis"
title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link></fr:author></fr:authors><fr:meta
name="external">https://www.youtube.com/watch?v=5AZIQFeluIY</fr:meta><fr:meta
name="venue">POPL 2021 Tutorial</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Till date, concurrency bugs inevitably find their way into concurrent software despite rigorous development-time testing. Data races are arguably the most insidious amongst concurrency bugs and are particularly hard to detect.</fr:p><fr:p>This tutorial focuses on recent developments in dynamic analysis techniques for detecting data races. Traditional dynamic race detection techniques, such as those based on Lamport’s happens-before (HB) partial order, are ineffective in exposing races that get ordered due to inexplicit synchronization, but can nevertheless be witnessed in alternate executions of the same underlying program. Predictive race detection techniques, on the other hand, aim to overcome this shortcoming of traditional dynamic race detectors by expose data races that can be missed by HB, without requiring a re-execution of the underlying program. The resulting promise of enhanced coverage in race detection has recently led to the development of many dynamic race prediction techniques.</fr:p><fr:p>In this tutorial we will discuss some of the state-of-the-art algorithms and techniques for dynamic data race prediction, present the foundations of race prediction in a principled manner and discuss some recent investigations on the complexity and hardness involved in reasoning about race prediction.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Context">Context</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>653</fr:anchor><fr:addr
type="user">dlws-0004</fr:addr><fr:route>dlws-0004.xml</fr:route><fr:title
text="Race prediction">Race prediction</fr:title><fr:taxon>Bibliography</fr:taxon><fr:authors><fr:author><fr:link
type="local"
href="daniellimws.xml"
addr="daniellimws"
title="Daniel Lim Wee Soong">Daniel Lim Wee Soong</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This page collects papers and dissertations about Race Prediction; if you have written a paper or dissertation on this topic, please <fr:link
type="external"
href="mailto:dws.lim@nus.edu.sg">write to me</fr:link> to have it added to this list.</fr:p><fr:p>Some works are titled "race detection" instead of "race prediction", the terminologies are often used interchangeably. Some of the works listed here are not directly on race prediction, but are important work in the history of this area.</fr:p>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>255</fr:anchor><fr:addr
type="machine">#246</fr:addr><fr:route>unstable-246.xml</fr:route><fr:title
text="Papers">Papers</fr:title><fr:authors><fr:author><fr:link
type="local"
href="daniellimws.xml"
addr="daniellimws"
title="Daniel Lim Wee Soong">Daniel Lim Wee Soong</fr:link></fr:author></fr:authors><fr:parent>dlws-0004</fr:parent></fr:frontmatter><fr:mainmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>257</fr:anchor><fr:addr
type="user">ang-mathur-prefix-2024</fr:addr><fr:route>ang-mathur-prefix-2024.xml</fr:route><fr:title
text="Predictive Monitoring with Strong Trace Prefixes">Predictive Monitoring with Strong Trace Prefixes</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month></fr:date><fr:authors><fr:author><fr:link
type="local"
href="zhendongang.xml"
addr="zhendongang"
title="Zhendong Ang">Zhendong Ang</fr:link></fr:author><fr:author><fr:link
type="local"
href="umangmathur.xml"
addr="umangmathur"
title="Umang Mathur">Umang Mathur</fr:link></fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@InProceedings{10.1007/978-3-031-65630-9_9,
author="Ang, Zhendong
and Mathur, Umang",
editor="Gurfinkel, Arie
and Ganesh, Vijay",
title="Predictive Monitoring with Strong Trace Prefixes",
booktitle="Computer Aided Verification",
year="2024",
publisher="Springer Nature Switzerland",
address="Cham",
pages="182--204",
abstract="Runtime predictive analyses enhance coverage of traditional dynamic analyses based bug detection techniques by identifying a space of feasible reorderings of the observed execution and determining if any reordering in this space witnesses the violation of some desired safety property. The most popular approach for modelling the space of feasible reorderings is through Mazurkiewicz's trace equivalence. The simplicity of the framework also gives rise to efficient predictive analyses, and has been the de facto means for obtaining space and time efficient algorithms for monitoring concurrent programs.",
isbn="978-3-031-65630-9"
}]]></fr:meta><fr:meta
name="doi">10.1007/978-3-031-65630-9_9</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>260</fr:anchor><fr:addr
type="user">zheng-mathur-pavlogiannis-osr-2024</fr:addr><fr:route>zheng-mathur-pavlogiannis-osr-2024.xml</fr:route><fr:title
text="Optimistic Prediction of Synchronization-Reversal Data Races">Optimistic Prediction of Synchronization-Reversal Data Races</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month></fr:date><fr:authors><fr:author><fr:link
type="local"
href="zhengshi.xml"
addr="zhengshi"
title="Zheng Shi">Zheng Shi</fr:link></fr:author><fr:author><fr:link
type="local"
href="umangmathur.xml"
addr="umangmathur"
title="Umang Mathur">Umang Mathur</fr:link></fr:author><fr:author><fr:link
type="local"
href="andreaspavlogiannis.xml"
addr="andreaspavlogiannis"
title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link></fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@inproceedings{10.1145/3597503.3639099,
author = {Shi, Zheng and Mathur, Umang and Pavlogiannis, Andreas},
title = {Optimistic Prediction of Synchronization-Reversal Data Races},
year = {2024},
isbn = {9798400702174},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3597503.3639099},
doi = {10.1145/3597503.3639099},
abstract = {Dynamic data race detection has emerged as a key technique for ensuring reliability of concurrent software in practice. However, dynamic approaches can often miss data races owing to non-determinism in the thread scheduler. Predictive race detection techniques cater to this shortcoming by inferring alternate executions that may expose data races without re-executing the underlying program. More formally, the dynamic data race prediction problem asks, given a trace σ of an execution of a concurrent program, can σ be correctly reordered to expose a data race? Existing state-of-the art techniques for data race prediction either do not scale to executions arising from real world concurrent software, or only expose a limited class of data races, such as those that can be exposed without reversing the order of synchronization operations.In general, exposing data races by reasoning about synchronization reversals is an intractable problem. In this work, we identify a class of data races, called Optimistic Sync(hronization)-Reversal races that can be detected in a tractable manner and often include non-trivial data races that cannot be exposed by prior tractable techniques. We also propose a sound algorithm OSR for detecting all optimistic sync-reversal data races in overall quadratic time, and show that the algorithm is optimal by establishing a matching lower bound. Our experiments demonstrate the effectiveness of OSR--- on our extensive suite of benchmarks, OSR reports the largest number of data races, and scales well to large execution traces.},
booktitle = {Proceedings of the IEEE/ACM 46th International Conference on Software Engineering},
articleno = {134},
numpages = {13},
location = {Lisbon, Portugal},
series = {ICSE '24}
}]]></fr:meta><fr:meta
name="doi">10.1145/3597503.3639099</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>264</fr:anchor><fr:addr
type="user">farzan-mathur-grain-2024</fr:addr><fr:route>farzan-mathur-grain-2024.xml</fr:route><fr:title
text="Coarser Equivalences for Causal Concurrency">Coarser Equivalences for Causal Concurrency</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month></fr:date><fr:authors><fr:author><fr:link
type="local"
href="azadehfarzan.xml"
addr="azadehfarzan"
title="Azadeh Farzan">Azadeh Farzan</fr:link></fr:author><fr:author><fr:link
type="local"
href="umangmathur.xml"
addr="umangmathur"
title="Umang Mathur">Umang Mathur</fr:link></fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@article{10.1145/3632873,
author = {Farzan, Azadeh and Mathur, Umang},
title = {Coarser Equivalences for Causal Concurrency},
year = {2024},
issue_date = {January 2024},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {POPL},
url = {https://doi.org/10.1145/3632873},
doi = {10.1145/3632873},
abstract = {Trace theory (formulated by Mazurkiewicz in 1987) is a principled framework for defining equivalence relations for concurrent program runs based on a commutativity relation over the set of atomic steps taken by individual program threads. Its simplicity, elegance, and algorithmic efficiency makes it useful in many different contexts including program verification and testing. It is well-understood that the larger the equivalence classes are, the more benefits they would bring to the algorithms and applications that use them. In this paper, we study relaxations of trace equivalence with the goal of maintaining its algorithmic advantages. We first prove that the largest appropriate relaxation of trace equivalence, an equivalence relation that preserves the order of steps taken by each thread and what write operation each read operation observes, does not yield efficient algorithms. Specifically, we prove a linear space lower bound for the problem of checking, in a streaming setting, if two arbitrary steps of a concurrent program run are causally concurrent (i.e. they can be reordered in an equivalent run) or causally ordered (i.e. they always appear in the same order in all equivalent runs). The same problem can be decided in constant space for trace equivalence. Next, we propose a new commutativity-based notion of equivalence called grain equivalence that is strictly more relaxed than trace equivalence, and yet yields a constant space algorithm for the same problem. This notion of equivalence uses commutativity of grains, which are sequences of atomic steps, in addition to the standard commutativity from trace theory. We study the two distinct cases when the grains are contiguous subwords of the input program run and when they are not, formulate the precise definition of causal concurrency in each case, and show that they can be decided in constant space, despite being strict relaxations of the notion of causal concurrency based on trace equivalence.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {31},
numpages = {31},
keywords = {concurrency, equivalence, predictive analysis, reads-from, reduction}
}]]></fr:meta><fr:meta
name="doi">10.1145/3632873</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>267</fr:anchor><fr:addr
type="user">ang-mathur-pattern-2024</fr:addr><fr:route>ang-mathur-pattern-2024.xml</fr:route><fr:title
text="Predictive Monitoring against Pattern Regular Languages">Predictive Monitoring against Pattern Regular Languages</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month></fr:date><fr:authors><fr:author><fr:link
type="local"
href="zhendongang.xml"
addr="zhendongang"
title="Zhendong Ang">Zhendong Ang</fr:link></fr:author><fr:author><fr:link
type="local"
href="umangmathur.xml"
addr="umangmathur"
title="Umang Mathur">Umang Mathur</fr:link></fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@article{10.1145/3632915,
author = {Ang, Zhendong and Mathur, Umang},
title = {Predictive Monitoring against Pattern Regular Languages},
year = {2024},
issue_date = {January 2024},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {POPL},
url = {https://doi.org/10.1145/3632915},
doi = {10.1145/3632915},
abstract = {While current bug detection techniques for concurrent software focus on unearthing low-level issues such as data races or deadlocks, they often fall short of discovering more intricate temporal behaviours that can arise even in the absence of such low-level issues. In this paper, we focus on the problem of dynamically analysing concurrent software against high-level temporal specifications such as LTL. Existing techniques for runtime monitoring against such specifications are primarily designed for sequential software and remain inadequate in the presence of concurrency — violations may be observed only in intricate thread interleavings, requiring many re-runs of the underlying software in conjunction with the analysis. Towards this, we study the problem of predictive runtime monitoring, inspired by the analogous problem of predictive data race detection studied extensively recently. The predictive runtime monitoring question asks, given an execution σ, if it can be soundly reordered to expose violations of a specification. In general, this problem may become easily intractable when either the specifications or the notion of reorderings used is complex. In this paper, we focus on specifications that are given in regular languages. Our notion of reorderings is trace equivalence, where an execution is considered a reordering of another if it can be obtained from the latter by successively commuting adjacent independent actions. We first show that, even in this simplistic setting, the problem of predictive monitoring admits a super-linear lower bound of O(nα), where n is the number of events in the execution, and α is a parameter describing the degree of commutativity, and typically corresponds to the number of threads in the execution. As a result, predictive runtime monitoring even in this setting is unlikely to be efficiently solvable, unlike in the non-predictive setting where the problem can be checked using a deterministic finite automaton (and thus, a constant-space streaming linear-time algorithm). Towards this, we identify a sub-class of regular languages, called pattern languages (and their extension generalized pattern languages). Pattern languages can naturally express specific ordering of some number of (labelled) events, and have been inspired by popular empirical hypotheses underlying many concurrency bug detection approaches such as the “small bug depth” hypothesis. More importantly, we show that for pattern (and generalized pattern) languages, the predictive monitoring problem can be solved using a constant-space streaming linear-time algorithm. We implement and evaluate our algorithm PatternTrack on benchmarks from the literature and show that it is effective in monitoring large-scale applications.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {73},
numpages = {35},
keywords = {complexity, concurrency, dynamic analysis, predictive monitoring}
}]]></fr:meta><fr:meta
name="doi">10.1145/3632915</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>270</fr:anchor><fr:addr
type="user">mathur-pavlogiannis-cantunç-viswanathan-treeclocks-2022</fr:addr><fr:route>mathur-pavlogiannis-cantunç-viswanathan-treeclocks-2022.xml</fr:route><fr:title
text="A tree clock data structure for causal orderings in concurrent executions">A tree clock data structure for causal orderings in concurrent executions</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2022</fr:year><fr:month>2</fr:month></fr:date><fr:authors><fr:author><fr:link
type="local"
href="umangmathur.xml"
addr="umangmathur"
title="Umang Mathur">Umang Mathur</fr:link></fr:author><fr:author><fr:link
type="local"
href="andreaspavlogiannis.xml"
addr="andreaspavlogiannis"
title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link></fr:author><fr:author><fr:link
type="local"
href="h%C3%BCnkarcantun%C3%A7.xml"
addr="hünkarcantunç"
title="Hünkar Can Tunç">Hünkar Can Tunç</fr:link></fr:author><fr:author><fr:link
type="local"
href="maheshviswanathan.xml"
addr="maheshviswanathan"
title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link></fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@inproceedings{10.1145/3503222.3507734,
author = {Mathur, Umang and Pavlogiannis, Andreas and Tun\c{c}, H\"{u}nkar Can and Viswanathan, Mahesh},
title = {A tree clock data structure for causal orderings in concurrent executions},
year = {2022},
isbn = {9781450392051},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3503222.3507734},
doi = {10.1145/3503222.3507734},
abstract = {Dynamic techniques are a scalable and effective way to analyze concurrent programs. Instead of analyzing all behaviors of a program, these techniques detect errors by focusing on a single program execution. Often a crucial step in these techniques is to define a causal ordering between events in the execution, which is then computed using vector clocks, a simple data structure that stores logical times of threads. The two basic operations of vector clocks, namely join and copy, require Θ(k) time, where k is the number of threads. Thus they are a computational bottleneck when k is large. In this work, we introduce tree clocks, a new data structure that replaces vector clocks for computing causal orderings in program executions. Joining and copying tree clocks takes time that is roughly proportional to the number of entries being modified, and hence the two operations do not suffer the a-priori Θ(k) cost per application. We show that when used to compute the classic happens-before (HB) partial order, tree clocks are optimal, in the sense that no other data structure can lead to smaller asymptotic running time. Moreover, we demonstrate that tree clocks can be used to compute other partial orders, such as schedulable-happens-before (SHB) and the standard Mazurkiewicz (MAZ) partial order, and thus are a versatile data structure. Our experiments show that just by replacing vector clocks with tree clocks, the computation becomes from 2.02 \texttimes{} faster (MAZ) to 2.66 \texttimes{} (SHB) and 2.97 \texttimes{} (HB) on average per benchmark. These results illustrate that tree clocks have the potential to become a standard data structure with wide applications in concurrent analyses.},
booktitle = {Proceedings of the 27th ACM International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {710–725},
numpages = {16},
keywords = {concurrency, dynamic analyses, happens-before, vector clocks},
location = {Lausanne, Switzerland},
series = {ASPLOS '22}
}]]></fr:meta><fr:meta
name="doi">10.1145/3503222.3507734</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>275</fr:anchor><fr:addr
type="user">mathur-pavlogiannis-viswanathan-syncp-2021</fr:addr><fr:route>mathur-pavlogiannis-viswanathan-syncp-2021.xml</fr:route><fr:title
text="Optimal prediction of synchronization-preserving races">Optimal prediction of synchronization-preserving races</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2021</fr:year><fr:month>1</fr:month></fr:date><fr:authors><fr:author><fr:link
type="local"
href="umangmathur.xml"
addr="umangmathur"
title="Umang Mathur">Umang Mathur</fr:link></fr:author><fr:author><fr:link
type="local"
href="andreaspavlogiannis.xml"
addr="andreaspavlogiannis"
title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link></fr:author><fr:author><fr:link
type="local"
href="maheshviswanathan.xml"
addr="maheshviswanathan"
title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link></fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@article{10.1145/3434317,
author = {Mathur, Umang and Pavlogiannis, Andreas and Viswanathan, Mahesh},
title = {Optimal prediction of synchronization-preserving races},
year = {2021},
issue_date = {January 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {POPL},
url = {https://doi.org/10.1145/3434317},
doi = {10.1145/3434317},
abstract = {Concurrent programs are notoriously hard to write correctly, as scheduling nondeterminism introduces subtle errors that are both hard to detect and to reproduce. The most common concurrency errors are (data) races, which occur when memory-conflicting actions are executed concurrently. Consequently, considerable effort has been made towards developing efficient techniques for race detection. The most common approach is dynamic race prediction: given an observed, race-free trace σ of a concurrent program, the task is to decide whether events of σ can be correctly reordered to a trace σ* that witnesses a race hidden in σ. In this work we introduce the notion of sync(hronization)-preserving races. A sync-preserving race occurs in σ when there is a witness σ* in which synchronization operations (e.g., acquisition and release of locks) appear in the same order as in σ. This is a broad definition that strictly subsumes the famous notion of happens-before races. Our main results are as follows. First, we develop a sound and complete algorithm for predicting sync-preserving races. For moderate values of parameters like the number of threads, the algorithm runs in \~{O}(N) time and space, where N is the length of the trace σ. Second, we show that the problem has a Ω(N/log2 N) space lower bound, and thus our algorithm is essentially time and space optimal. Third, we show that predicting races with even just a single reversal of two sync operations is NP-complete and even W1-hard when parameterized by the number of threads. Thus, sync-preservation characterizes exactly the tractability boundary of race prediction, and our algorithm is nearly optimal for the tractable side. Our experiments show that our algorithm is fast in practice, while sync-preservation characterizes races often missed by state-of-the-art methods.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {36},
numpages = {29},
keywords = {race detection, dynamic analysis, concurrency, complexity}
}]]></fr:meta><fr:meta
name="doi">10.1145/3434317</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>279</fr:anchor><fr:addr
type="user">pavlogiannis-m2-2019</fr:addr><fr:route>pavlogiannis-m2-2019.xml</fr:route><fr:title
text="Fast, sound, and effectively complete dynamic race prediction">Fast, sound, and effectively complete dynamic race prediction</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2019</fr:year><fr:month>12</fr:month></fr:date><fr:authors><fr:author><fr:link
type="local"
href="andreaspavlogiannis.xml"
addr="andreaspavlogiannis"
title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link></fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@article{10.1145/3371085,
author = {Pavlogiannis, Andreas},
title = {Fast, sound, and effectively complete dynamic race prediction},
year = {2019},
issue_date = {January 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {POPL},
url = {https://doi.org/10.1145/3371085},
doi = {10.1145/3371085},
abstract = {Writing concurrent programs is highly error-prone due to the nondeterminism in interprocess communication. The most reliable indicators of errors in concurrency are data races, which are accesses to a shared resource that can be executed concurrently. We study the problem of predicting data races in lock-based concurrent programs. The input consists of a concurrent trace t, and the task is to determine all pairs of events of t that constitute a data race. The problem lies at the heart of concurrent verification and has been extensively studied for over three decades. However, existing polynomial-time sound techniques are highly incomplete and can miss simple races. In this work we develop M2: a new polynomial-time algorithm for this problem, which has no false positives. In addition, our algorithm is complete for input traces that consist of two processes, i.e., it provably detects all races in the trace. We also develop sufficient criteria for detecting completeness dynamically in cases of more than two processes. We make an experimental evaluation of our algorithm on a challenging set of benchmarks taken from recent literature on the topic. Our algorithm soundly reports hundreds of real races, many of which are missed by existing methods. In addition, using our dynamic completeness criteria, M2 concludes that it has detected all races in the benchmark set, hence the reports are both sound and complete. Finally, its running times are comparable, and often smaller than the theoretically fastest, yet highly incomplete, existing methods. To our knowledge, M2 is the first sound algorithm that achieves such a level of performance on both running time and completeness of the reported races.},
journal = {Proc. ACM Program. Lang.},
month = {dec},
articleno = {17},
numpages = {29},
keywords = {race detection, predictive analyses, concurrency}
}]]></fr:meta><fr:meta
name="doi">10.1145/3371085</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>281</fr:anchor><fr:addr
type="user">mathur-kini-viswanathan-shb-2018</fr:addr><fr:route>mathur-kini-viswanathan-shb-2018.xml</fr:route><fr:title
text="What happens-after the first race? Enhancing the predictive power of happens-before based dynamic race detection">What happens-after the first race? Enhancing the predictive power of happens-before based dynamic race detection</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2018</fr:year><fr:month>10</fr:month></fr:date><fr:authors><fr:author><fr:link
type="local"
href="umangmathur.xml"
addr="umangmathur"
title="Umang Mathur">Umang Mathur</fr:link></fr:author><fr:author>Dileep Kini</fr:author><fr:author><fr:link
type="local"
href="maheshviswanathan.xml"
addr="maheshviswanathan"
title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link></fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@article{10.1145/3276515,
author = {Mathur, Umang and Kini, Dileep and Viswanathan, Mahesh},
title = {What happens-after the first race? enhancing the predictive power of happens-before based dynamic race detection},
year = {2018},
issue_date = {November 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {OOPSLA},
url = {https://doi.org/10.1145/3276515},
doi = {10.1145/3276515},
abstract = {Dynamic race detection is the problem of determining if an observed program execution reveals the presence of a data race in a program. The classical approach to solving this problem is to detect if there is a pair of conflicting memory accesses that are unordered by Lamport’s happens-before (HB) relation. HB based race detection is known to not report false positives, i.e., it is sound. However, the soundness guarantee of HB only promises that the first pair of unordered, conflicting events is a schedulable data race. That is, there can be pairs of HB-unordered conflicting data accesses that are not schedulable races because there is no reordering of the events of the execution, where the events in race can be executed immediately after each other. We introduce a new partial order, called schedulable happens-before (SHB) that exactly characterizes the pairs of schedulable data races — every pair of conflicting data accesses that are identified by SHB can be scheduled, and every HB-race that can be scheduled is identified by SHB. Thus, the SHB partial order is truly sound. We present a linear time, vector clock algorithm to detect schedulable races using SHB. Our experiments demonstrate the value of our algorithm for dynamic race detection — SHB incurs only little performance overhead and can scale to executions from real-world software applications without compromising soundness.},
journal = {Proc. ACM Program. Lang.},
month = {oct},
articleno = {145},
numpages = {29},
keywords = {Concurrency, Dynamic Program Analysis, Happens-Before, Race Detection, Soundness}
}]]></fr:meta><fr:meta
name="doi">10.1145/3276515</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>285</fr:anchor><fr:addr
type="user">kini-mathur-viswanathan-wcp-2017</fr:addr><fr:route>kini-mathur-viswanathan-wcp-2017.xml</fr:route><fr:title
text="Dynamic race prediction in linear time">Dynamic race prediction in linear time</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2017</fr:year><fr:month>6</fr:month></fr:date><fr:authors><fr:author>Dileep Kini</fr:author><fr:author><fr:link
type="local"
href="umangmathur.xml"
addr="umangmathur"
title="Umang Mathur">Umang Mathur</fr:link></fr:author><fr:author><fr:link
type="local"
href="maheshviswanathan.xml"
addr="maheshviswanathan"
title="Mahesh Viswanathan">Mahesh Viswanathan</fr:link></fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@inproceedings{10.1145/3062341.3062374,
author = {Kini, Dileep and Mathur, Umang and Viswanathan, Mahesh},
title = {Dynamic race prediction in linear time},
year = {2017},
isbn = {9781450349888},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3062341.3062374},
doi = {10.1145/3062341.3062374},
abstract = {Writing reliable concurrent software remains a huge challenge for today's programmers. Programmers rarely reason about their code by explicitly considering different possible inter-leavings of its execution. We consider the problem of detecting data races from individual executions in a sound manner. The classical approach to solving this problem has been to use Lamport's happens-before (HB) relation. Until now HB remains the only approach that runs in linear time. Previous efforts in improving over HB such as causally-precedes (CP) and maximal causal models fall short due to the fact that they are not implementable efficiently and hence have to compromise on their race detecting ability by limiting their techniques to bounded sized fragments of the execution. We present a new relation weak-causally-precedes (WCP) that is provably better than CP in terms of being able to detect more races, while still remaining sound. Moreover, it admits a linear time algorithm which works on the entire execution without having to fragment it.},
booktitle = {Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {157–170},
numpages = {14},
keywords = {Race Prediction, Online Algorithm, Concurrency},
location = {Barcelona, Spain},
series = {PLDI 2017}
}

@article{10.1145/3140587.3062374,
author = {Kini, Dileep and Mathur, Umang and Viswanathan, Mahesh},
title = {Dynamic race prediction in linear time},
year = {2017},
issue_date = {June 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/3140587.3062374},
doi = {10.1145/3140587.3062374},
abstract = {Writing reliable concurrent software remains a huge challenge for today's programmers. Programmers rarely reason about their code by explicitly considering different possible inter-leavings of its execution. We consider the problem of detecting data races from individual executions in a sound manner. The classical approach to solving this problem has been to use Lamport's happens-before (HB) relation. Until now HB remains the only approach that runs in linear time. Previous efforts in improving over HB such as causally-precedes (CP) and maximal causal models fall short due to the fact that they are not implementable efficiently and hence have to compromise on their race detecting ability by limiting their techniques to bounded sized fragments of the execution. We present a new relation weak-causally-precedes (WCP) that is provably better than CP in terms of being able to detect more races, while still remaining sound. Moreover, it admits a linear time algorithm which works on the entire execution without having to fragment it.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {157–170},
numpages = {14},
keywords = {Race Prediction, Online Algorithm, Concurrency}
}]]></fr:meta><fr:meta
name="doi">10.1145/3062341.3062374</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>289</fr:anchor><fr:addr
type="user">huang-meredith-rosu-rvpredict-2014</fr:addr><fr:route>huang-meredith-rosu-rvpredict-2014.xml</fr:route><fr:title
text="Maximal sound predictive race detection with control flow abstraction">Maximal sound predictive race detection with control flow abstraction</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2014</fr:year><fr:month>6</fr:month></fr:date><fr:authors><fr:author>Jeff Huang</fr:author><fr:author>Patrick O’Neil Meredith</fr:author><fr:author><fr:link
type="local"
href="grigorerosu.xml"
addr="grigorerosu"
title="Grigore Rosu">Grigore Rosu</fr:link></fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@inproceedings{10.1145/2594291.2594315,
author = {Huang, Jeff and Meredith, Patrick O'Neil and Rosu, Grigore},
title = {Maximal sound predictive race detection with control flow abstraction},
year = {2014},
isbn = {9781450327848},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2594291.2594315},
doi = {10.1145/2594291.2594315},
abstract = {Despite the numerous static and dynamic program analysis techniques in the literature, data races remain one of the most common bugs in modern concurrent software. Further, the techniques that do exist either have limited detection capability or are unsound, meaning that they report false positives. We present a sound race detection technique that achieves a provably higher detection capability than existing sound techniques. A key insight of our technique is the inclusion of abstracted control flow information into the execution model, which increases the space of the causal model permitted by classical happens-before or causally-precedes based detectors. By encoding the control flow and a minimal set of feasibility constraints as a group of first-order logic formulae, we formulate race detection as a constraint solving problem. Moreover, we formally prove that our formulation achieves the maximal possible detection capability for any sound dynamic race detector with respect to the same input trace under the sequential consistency memory model. We demonstrate via extensive experimentation that our technique detects more races than the other state-of-the-art sound race detection techniques, and that it is scalable to executions of real world concurrent applications with tens of millions of critical events. These experiments also revealed several previously unknown races in real systems (e.g., Eclipse) that have been confirmed or fixed by the developers. Our tool is also adopted by Eclipse developers.},
booktitle = {Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {337–348},
numpages = {12},
keywords = {control flow, data race, maximal sound, prediction},
location = {Edinburgh, United Kingdom},
series = {PLDI '14}
}

@article{10.1145/2666356.2594315,
author = {Huang, Jeff and Meredith, Patrick O'Neil and Rosu, Grigore},
title = {Maximal sound predictive race detection with control flow abstraction},
year = {2014},
issue_date = {June 2014},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {49},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/2666356.2594315},
doi = {10.1145/2666356.2594315},
abstract = {Despite the numerous static and dynamic program analysis techniques in the literature, data races remain one of the most common bugs in modern concurrent software. Further, the techniques that do exist either have limited detection capability or are unsound, meaning that they report false positives. We present a sound race detection technique that achieves a provably higher detection capability than existing sound techniques. A key insight of our technique is the inclusion of abstracted control flow information into the execution model, which increases the space of the causal model permitted by classical happens-before or causally-precedes based detectors. By encoding the control flow and a minimal set of feasibility constraints as a group of first-order logic formulae, we formulate race detection as a constraint solving problem. Moreover, we formally prove that our formulation achieves the maximal possible detection capability for any sound dynamic race detector with respect to the same input trace under the sequential consistency memory model. We demonstrate via extensive experimentation that our technique detects more races than the other state-of-the-art sound race detection techniques, and that it is scalable to executions of real world concurrent applications with tens of millions of critical events. These experiments also revealed several previously unknown races in real systems (e.g., Eclipse) that have been confirmed or fixed by the developers. Our tool is also adopted by Eclipse developers.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {337–348},
numpages = {12},
keywords = {control flow, data race, maximal sound, prediction}
}]]></fr:meta><fr:meta
name="doi">10.1145/2594291.2594315</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>293</fr:anchor><fr:addr
type="user">smaragdakis-cp-2012</fr:addr><fr:route>smaragdakis-cp-2012.xml</fr:route><fr:title
text="Sound predictive race detection in polynomial time">Sound predictive race detection in polynomial time</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2012</fr:year><fr:month>1</fr:month></fr:date><fr:authors><fr:author>Yannis Smaragdakis</fr:author><fr:author>Jacob M. Evans</fr:author><fr:author>Caitlin Sadowski</fr:author><fr:author>Jaeheon Yi</fr:author><fr:author>Cormac Flanagan</fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@inproceedings{10.1145/2103656.2103702,
author = {Smaragdakis, Yannis and Evans, Jacob and Sadowski, Caitlin and Yi, Jaeheon and Flanagan, Cormac},
title = {Sound predictive race detection in polynomial time},
year = {2012},
isbn = {9781450310833},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2103656.2103702},
doi = {10.1145/2103656.2103702},
abstract = {Data races are among the most reliable indicators of programming errors in concurrent software. For at least two decades, Lamport's happens-before (HB) relation has served as the standard test for detecting races--other techniques, such as lockset-based approaches, fail to be sound, as they may falsely warn of races. This work introduces a new relation, causally-precedes (CP), which generalizes happens-before to observe more races without sacrificing soundness. Intuitively, CP tries to capture the concept of happens-before ordered events that must occur in the observed order for the program to observe the same values. What distinguishes CP from past predictive race detection approaches (which also generalize an observed execution to detect races in other plausible executions) is that CP-based race detection is both sound and of polynomial complexity. We demonstrate that the unique aspects of CP result in practical benefit. Applying CP to real-world programs, we successfully analyze server-level applications (e.g., Apache FtpServer) and show that traces longer than in past predictive race analyses can be analyzed in mere seconds to a few minutes. For these programs, CP race detection uncovers races that are hard to detect by repeated execution and HB race detection: a single run of CP race detection produces several races not discovered by 10 separate rounds of happens-before race detection.},
booktitle = {Proceedings of the 39th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {387–400},
numpages = {14},
keywords = {dynamic analysis, happens-before, race detection},
location = {Philadelphia, PA, USA},
series = {POPL '12}
}

@article{10.1145/2103621.2103702,
author = {Smaragdakis, Yannis and Evans, Jacob and Sadowski, Caitlin and Yi, Jaeheon and Flanagan, Cormac},
title = {Sound predictive race detection in polynomial time},
year = {2012},
issue_date = {January 2012},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {47},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/2103621.2103702},
doi = {10.1145/2103621.2103702},
abstract = {Data races are among the most reliable indicators of programming errors in concurrent software. For at least two decades, Lamport's happens-before (HB) relation has served as the standard test for detecting races--other techniques, such as lockset-based approaches, fail to be sound, as they may falsely warn of races. This work introduces a new relation, causally-precedes (CP), which generalizes happens-before to observe more races without sacrificing soundness. Intuitively, CP tries to capture the concept of happens-before ordered events that must occur in the observed order for the program to observe the same values. What distinguishes CP from past predictive race detection approaches (which also generalize an observed execution to detect races in other plausible executions) is that CP-based race detection is both sound and of polynomial complexity. We demonstrate that the unique aspects of CP result in practical benefit. Applying CP to real-world programs, we successfully analyze server-level applications (e.g., Apache FtpServer) and show that traces longer than in past predictive race analyses can be analyzed in mere seconds to a few minutes. For these programs, CP race detection uncovers races that are hard to detect by repeated execution and HB race detection: a single run of CP race detection produces several races not discovered by 10 separate rounds of happens-before race detection.},
journal = {SIGPLAN Not.},
month = {jan},
pages = {387–400},
numpages = {14},
keywords = {dynamic analysis, happens-before, race detection}
}]]></fr:meta><fr:meta
name="doi">10.1145/2103656.2103702</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>299</fr:anchor><fr:addr
type="user">flanagan-freund-fasttrack-2009</fr:addr><fr:route>flanagan-freund-fasttrack-2009.xml</fr:route><fr:title
text="FastTrack: efficient and precise dynamic race detection">FastTrack: efficient and precise dynamic race detection</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2009</fr:year><fr:month>6</fr:month></fr:date><fr:authors><fr:author>Cormac Flanagan</fr:author><fr:author>Stephen N. Freund</fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@article{10.1145/1543135.1542490,
author = {Flanagan, Cormac and Freund, Stephen N.},
title = {FastTrack: efficient and precise dynamic race detection},
year = {2009},
issue_date = {June 2009},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {44},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/1543135.1542490},
doi = {10.1145/1543135.1542490},
abstract = {begin{abstract}Multithreaded programs are notoriously prone to race conditions. Prior work on dynamic race detectors includes fast but imprecise race detectors that report false alarms, as well as slow but precise race detectors that never report false alarms. The latter typically use expensive vector clock operations that require time linear in the number of program threads.This paper exploits the insight that the full generality of vector clocks is unnecessary in most cases. That is, we can replace heavyweight vector clocks with an adaptive lightweight representation that, for almost all operations of the target program, requires only constant space and supports constant-time operations. This representation change significantly improves time and space performance, with no loss in precision.Experimental results on Java benchmarks including the Eclipse development environment show that our FastTrack race detector is an order of magnitude faster than a traditional vector-clock race detector, and roughly twice as fast as the high-performance DJIT+ algorithm. FastTrack is even comparable in speed to Eraser on our Java benchmarks, while never reporting false alarms.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {121–133},
numpages = {13},
keywords = {race conditions, dynamic analysis, concurrency}
}

@inproceedings{10.1145/1542476.1542490,
author = {Flanagan, Cormac and Freund, Stephen N.},
title = {FastTrack: efficient and precise dynamic race detection},
year = {2009},
isbn = {9781605583921},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1542476.1542490},
doi = {10.1145/1542476.1542490},
abstract = {begin{abstract}Multithreaded programs are notoriously prone to race conditions. Prior work on dynamic race detectors includes fast but imprecise race detectors that report false alarms, as well as slow but precise race detectors that never report false alarms. The latter typically use expensive vector clock operations that require time linear in the number of program threads.This paper exploits the insight that the full generality of vector clocks is unnecessary in most cases. That is, we can replace heavyweight vector clocks with an adaptive lightweight representation that, for almost all operations of the target program, requires only constant space and supports constant-time operations. This representation change significantly improves time and space performance, with no loss in precision.Experimental results on Java benchmarks including the Eclipse development environment show that our FastTrack race detector is an order of magnitude faster than a traditional vector-clock race detector, and roughly twice as fast as the high-performance DJIT+ algorithm. FastTrack is even comparable in speed to Eraser on our Java benchmarks, while never reporting false alarms.},
booktitle = {Proceedings of the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {121–133},
numpages = {13},
keywords = {race conditions, dynamic analysis, concurrency},
location = {Dublin, Ireland},
series = {PLDI '09}
}]]></fr:meta><fr:meta
name="doi">10.1145/1543135.1542490</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>302</fr:anchor><fr:addr
type="user">elmas-goldilocks-2007</fr:addr><fr:route>elmas-goldilocks-2007.xml</fr:route><fr:title
text="Goldilocks: a race and transaction-aware java runtime">Goldilocks: a race and transaction-aware java runtime</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2007</fr:year><fr:month>6</fr:month></fr:date><fr:authors><fr:author>Tayfun Elmas</fr:author><fr:author>Shaz Qadeer</fr:author><fr:author>Serdar Tasiran</fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@article{10.1145/1273442.1250762,
author = {Elmas, Tayfun and Qadeer, Shaz and Tasiran, Serdar},
title = {Goldilocks: a race and transaction-aware java runtime},
year = {2007},
issue_date = {June 2007},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {42},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/1273442.1250762},
doi = {10.1145/1273442.1250762},
abstract = {Data races often result in unexpected and erroneous behavior. In addition to causing data corruption and leading programs to crash, the presence of data races complicates the semantics of an execution which might no longer be sequentially consistent. Motivated by these observations, we have designed and implemented a Java runtime system that monitors program executions and throws a DataRaceException when a data race is about to occur. Analogous to other runtime exceptions, the DataRaceException provides two key benefits. First, accesses causing race conditions are interruptedand handled before they cause errors that may be difficult to diagnose later. Second, if no DataRaceException is thrown in an execution, it is guaranteed to be sequentially consistent. This strong guarantee helps to rule out many concurrency-related possibilities as the cause of erroneous behavior. When a DataRaceException is caught, the operation, thread, or program causing it can be terminated gracefully. Alternatively, the DataRaceException can serve as a conflict-detection mechanism inoptimistic uses of concurrency.We start with the definition of data-race-free executions in the Java memory model. We generalize this definition to executions that use transactions in addition to locks and volatile variables for synchronization. We present a precise and efficient algorithm for dynamically verifying that an execution is free of data races. This algorithm generalizes the Goldilocks algorithm for data-race detectionby handling transactions and providing the ability to distinguish between read and write accesses. We have implemented our algorithm and the DataRaceException in the Kaffe Java Virtual Machine. We have evaluated our system on a variety of publicly available Java benchmarks and a few microbenchmarks that combine lock-based and transaction-based synchronization. Our experiments indicate that our implementation has reasonable overhead. Therefore, we believe that inaddition to being a debugging tool, the DataRaceException may be a viable mechanism to enforce the safety of executions of multithreaded Java programs.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {245–255},
numpages = {11},
keywords = {Java runtime, data-race detection, runtime monitoring, software transactions}
}

@inproceedings{10.1145/1250734.1250762,
author = {Elmas, Tayfun and Qadeer, Shaz and Tasiran, Serdar},
title = {Goldilocks: a race and transaction-aware java runtime},
year = {2007},
isbn = {9781595936332},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1250734.1250762},
doi = {10.1145/1250734.1250762},
abstract = {Data races often result in unexpected and erroneous behavior. In addition to causing data corruption and leading programs to crash, the presence of data races complicates the semantics of an execution which might no longer be sequentially consistent. Motivated by these observations, we have designed and implemented a Java runtime system that monitors program executions and throws a DataRaceException when a data race is about to occur. Analogous to other runtime exceptions, the DataRaceException provides two key benefits. First, accesses causing race conditions are interruptedand handled before they cause errors that may be difficult to diagnose later. Second, if no DataRaceException is thrown in an execution, it is guaranteed to be sequentially consistent. This strong guarantee helps to rule out many concurrency-related possibilities as the cause of erroneous behavior. When a DataRaceException is caught, the operation, thread, or program causing it can be terminated gracefully. Alternatively, the DataRaceException can serve as a conflict-detection mechanism inoptimistic uses of concurrency.We start with the definition of data-race-free executions in the Java memory model. We generalize this definition to executions that use transactions in addition to locks and volatile variables for synchronization. We present a precise and efficient algorithm for dynamically verifying that an execution is free of data races. This algorithm generalizes the Goldilocks algorithm for data-race detectionby handling transactions and providing the ability to distinguish between read and write accesses. We have implemented our algorithm and the DataRaceException in the Kaffe Java Virtual Machine. We have evaluated our system on a variety of publicly available Java benchmarks and a few microbenchmarks that combine lock-based and transaction-based synchronization. Our experiments indicate that our implementation has reasonable overhead. Therefore, we believe that inaddition to being a debugging tool, the DataRaceException may be a viable mechanism to enforce the safety of executions of multithreaded Java programs.},
booktitle = {Proceedings of the 28th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {245–255},
numpages = {11},
keywords = {Java runtime, data-race detection, runtime monitoring, software transactions},
location = {San Diego, California, USA},
series = {PLDI '07}
}]]></fr:meta><fr:meta
name="doi">10.1145/1273442.1250762</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>306</fr:anchor><fr:addr
type="user">pozniansky-schuster-djit+-2006</fr:addr><fr:route>pozniansky-schuster-djit+-2006.xml</fr:route><fr:title
text="MultiRace: efficient on-the-fly data race detection in multithreaded C++ programs">MultiRace: efficient on-the-fly data race detection in multithreaded C++ programs</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2006</fr:year><fr:month>8</fr:month></fr:date><fr:authors><fr:author>Eli Pozniansky</fr:author><fr:author>Assaf Schuster</fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@article{https://doi.org/10.1002/cpe.1064,
author = {Pozniansky, Eli and Schuster, Assaf},
title = {MultiRace: efficient on-the-fly data race detection in multithreaded C++ programs},
journal = {Concurrency and Computation: Practice and Experience},
volume = {19},
number = {3},
pages = {327-340},
keywords = {data race, concurrency, multithreading, instrumentation, synchronization},
doi = {https://doi.org/10.1002/cpe.1064},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/cpe.1064},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/cpe.1064},
abstract = {Abstract Data race detection is highly essential for debugging multithreaded programs and assuring their correctness. Nevertheless, there is no single universal technique capable of handling the task efficiently, since the data race detection problem is computationally hard in the general case. Thus, all currently available tools, when applied to some general case program, usually result in excessive false alarms or in a large number of undetected races. Another major drawback of many currently available tools is that they are restricted, for performance reasons, to detection units of fixed size. Thus, they all suffer from the same problem—choosing a small unit might result in missing some of the data races, while choosing a large one might lead to false detection. We present a novel testing tool, called MultiRace, which combines improved versions of Djit and Lockset—two very powerful on-the-fly algorithms for dynamic detection of apparent data races. Both extended algorithms detect races in multithreaded programs that may execute on weak consistency systems, and may use two-way as well as global synchronization primitives. By employing novel technologies, MultiRace adjusts its detection to the native granularity of objects and variables in the program under examination. In order to monitor all accesses to each of the shared locations, MultiRace instruments the C++ source code of the program. It lets the user fine-tune the detection process, but otherwise is completely automatic and transparent. This paper describes the algorithms employed in MultiRace, gives highlights of its implementation issues, and suggests some optimizations. It shows that the overheads imposed by MultiRace are often much smaller (orders of magnitude) than those obtained by other existing tools. Copyright © 2006 John Wiley \& Sons, Ltd.},
year = {2007}
}]]></fr:meta><fr:meta
name="doi">10.1002/cpe.1064</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>309</fr:anchor><fr:addr
type="user">itzkovitz-djit-1999</fr:addr><fr:route>itzkovitz-djit-1999.xml</fr:route><fr:title
text="Toward Integration of Data Race Detection in DSM Systems">Toward Integration of Data Race Detection in DSM Systems</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>1999</fr:year><fr:month>6</fr:month></fr:date><fr:authors><fr:author>Ayal Itzkovitz</fr:author><fr:author>Assaf Schuster</fr:author><fr:author>Oren Zeev-Ben-Mordehai</fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@article{ITZKOVITZ1999180,
title = {Toward Integration of Data Race Detection in DSM Systems},
journal = {Journal of Parallel and Distributed Computing},
volume = {59},
number = {2},
pages = {180-203},
year = {1999},
issn = {0743-7315},
doi = {https://doi.org/10.1006/jpdc.1999.1574},
url = {https://www.sciencedirect.com/science/article/pii/S0743731599915745},
author = {Ayal Itzkovitz and Assaf Schuster and Oren Zeev-Ben-Mordehai},
keywords = {distributed shared memory, parallel computation, data race detection, debugging tools},
abstract = {We present a distributed algorithm, called djit, for detecting data races in dsm systems. djit is designed as a dsm add-on, detecting a race condition as soon as one is created. It instantly displays to the user the precise place in the program where the race occurred. There are no false detections, and no data races are missed. We have implemented djit on top of millipage—a fine granularity, page-based dsm system. Our implementation makes novel use of the operating system protection mechanisms. In particular, we propose a protection cache, which can be used for local logging of accesses to variables. As a result, our implementation does not increase the message complexity of the execution, piggybacking all its communication activity on top of the dsm-related messages. The performance figures show that our data race detection mechanism has only a minor influence on performance. The measured overheads, averaging only few percent, are two orders of magnitude smaller than those achieved in previous work. Thus, our technique makes the integration of on-the-fly data race detection during the regular dsm execution feasible for the first time.}
}]]></fr:meta><fr:meta
name="doi">10.1006/jpdc.1999.1574</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>313</fr:anchor><fr:addr
type="user">savage-eraser-97</fr:addr><fr:route>savage-eraser-97.xml</fr:route><fr:title
text="Eraser: a dynamic data race detector for multithreaded programs">Eraser: a dynamic data race detector for multithreaded programs</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>1997</fr:year><fr:month>11</fr:month></fr:date><fr:authors><fr:author>Stefan Savage</fr:author><fr:author>Michael Burrows</fr:author><fr:author>Greg Nelson</fr:author><fr:author>Patrick Sobalvarro</fr:author><fr:author>Thomas Anderson</fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@article{10.1145/265924.265927,
author = {Savage, Stefan and Burrows, Michael and Nelson, Greg and Sobalvarro, Patrick and Anderson, Thomas},
title = {Eraser: a dynamic data race detector for multithreaded programs},
year = {1997},
issue_date = {Nov. 1997},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {15},
number = {4},
issn = {0734-2071},
url = {https://doi.org/10.1145/265924.265927},
doi = {10.1145/265924.265927},
abstract = {Multithreaded programming is difficult and error prone. It is easy to make a mistake in synchronization that produces a data race, yet it can be extremely hard to locate this mistake during debugging. This article describes a new tool, called Eraser, for dynamically detecting data races in lock-based multithreaded programs. Eraser uses binary rewriting techniques to monitor every shared-monory reference and verify that consistent locking behavior is observed. We present several case studies, including undergraduate coursework and a multithreaded Web search engine, that demonstrate the effectiveness of this approach.},
journal = {ACM Trans. Comput. Syst.},
month = {nov},
pages = {391–411},
numpages = {21},
keywords = {binary code modification, multithreaded programming, race detection}
}]]></fr:meta><fr:meta
name="doi">10.1145/265924.265927</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>319</fr:anchor><fr:addr
type="user">lamport-clocks-1978</fr:addr><fr:route>lamport-clocks-1978.xml</fr:route><fr:title
text="Time, clocks, and the ordering of events in a distributed system">Time, clocks, and the ordering of events in a distributed system</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>1978</fr:year><fr:month>7</fr:month></fr:date><fr:authors><fr:author>Leslie Lamport</fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@article{10.1145/359545.359563,
author = {Lamport, Leslie},
title = {Time, clocks, and the ordering of events in a distributed system},
year = {1978},
issue_date = {July 1978},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {21},
number = {7},
issn = {0001-0782},
url = {https://doi.org/10.1145/359545.359563},
doi = {10.1145/359545.359563},
abstract = {The concept of one event happening before another in a distributed system is examined, and is shown to define a partial ordering of the events. A distributed algorithm is given for synchronizing a system of logical clocks which can be used to totally order the events. The use of the total ordering is illustrated with a method for solving synchronization problems. The algorithm is then specialized for synchronizing physical clocks, and a bound is derived on how far out of synchrony the clocks can become.},
journal = {Commun. ACM},
month = {jul},
pages = {558–565},
numpages = {8},
keywords = {multiprocess systems, distributed systems, computer networks, clock synchronization}
}]]></fr:meta><fr:meta
name="doi">10.1145/359545.359563</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree>


  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>321</fr:anchor><fr:addr
type="machine">#247</fr:addr><fr:route>unstable-247.xml</fr:route><fr:title
text="Talks">Talks</fr:title><fr:authors><fr:author><fr:link
type="local"
href="daniellimws.xml"
addr="daniellimws"
title="Daniel Lim Wee Soong">Daniel Lim Wee Soong</fr:link></fr:author></fr:authors><fr:parent>dlws-0004</fr:parent></fr:frontmatter><fr:mainmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>323</fr:anchor><fr:addr
type="user">farzan-grain-2024-iarcs</fr:addr><fr:route>farzan-grain-2024-iarcs.xml</fr:route><fr:title
text="Coarser Equivalences for Causal Concurrency">Coarser Equivalences for Causal Concurrency</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month></fr:date><fr:authors><fr:author><fr:link
type="local"
href="azadehfarzan.xml"
addr="azadehfarzan"
title="Azadeh Farzan">Azadeh Farzan</fr:link></fr:author></fr:authors><fr:meta
name="external">https://www.youtube.com/watch?v=hYJv7Pf53yU</fr:meta><fr:meta
name="venue">IARCS Verification Seminar</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>325</fr:anchor><fr:addr
type="user">mathur-pavlogiannis-2021-asplos</fr:addr><fr:route>mathur-pavlogiannis-2021-asplos.xml</fr:route><fr:title
text="Dynamic Data-Race Prediction : Fundamentals, Theory and Practice">Dynamic Data-Race Prediction : Fundamentals, Theory and Practice</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2021</fr:year><fr:month>4</fr:month></fr:date><fr:authors><fr:author><fr:link
type="local"
href="umangmathur.xml"
addr="umangmathur"
title="Umang Mathur">Umang Mathur</fr:link></fr:author><fr:author><fr:link
type="local"
href="andreaspavlogiannis.xml"
addr="andreaspavlogiannis"
title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link></fr:author></fr:authors><fr:meta
name="external">https://www.youtube.com/watch?v=B6q2NQ5Tp2I</fr:meta><fr:meta
name="venue">ASPLOS 2021 Tutorial</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Data races are arguably the most insidious amongst concurrency bugs and extensive research efforts have been dedicated to effectively detect them. Predictive race detection techniques aim to expose data races missed by traditional dynamic race detectors (such as those based on Happens-Before) by inferring data races in alternate executions of the underlying program, without re-executing it. The resulting promise of enhanced coverage in race detection has recently led to the development of many dynamic race prediction techniques.</fr:p><fr:p>This tutorial aims to present the foundations of race prediction in a principled manner, consolidate a decade long line of work on dynamic race prediction and discusses recent algorithmic advances that make race prediction efficient and practical. This tutorial also aims to discuss some recent results on the complexity and hardness involved in reasoning about race prediction.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>328</fr:anchor><fr:addr
type="user">mathur-pavlogiannis-2021-popl</fr:addr><fr:route>mathur-pavlogiannis-2021-popl.xml</fr:route><fr:title
text="Dynamic Data-Race Prediction: Fundamentals, Theory and Practice">Dynamic Data-Race Prediction: Fundamentals, Theory and Practice</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2021</fr:year><fr:month>1</fr:month></fr:date><fr:authors><fr:author><fr:link
type="local"
href="umangmathur.xml"
addr="umangmathur"
title="Umang Mathur">Umang Mathur</fr:link></fr:author><fr:author><fr:link
type="local"
href="andreaspavlogiannis.xml"
addr="andreaspavlogiannis"
title="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:link></fr:author></fr:authors><fr:meta
name="external">https://www.youtube.com/watch?v=5AZIQFeluIY</fr:meta><fr:meta
name="venue">POPL 2021 Tutorial</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Till date, concurrency bugs inevitably find their way into concurrent software despite rigorous development-time testing. Data races are arguably the most insidious amongst concurrency bugs and are particularly hard to detect.</fr:p><fr:p>This tutorial focuses on recent developments in dynamic analysis techniques for detecting data races. Traditional dynamic race detection techniques, such as those based on Lamport’s happens-before (HB) partial order, are ineffective in exposing races that get ordered due to inexplicit synchronization, but can nevertheless be witnessed in alternate executions of the same underlying program. Predictive race detection techniques, on the other hand, aim to overcome this shortcoming of traditional dynamic race detectors by expose data races that can be missed by HB, without requiring a re-execution of the underlying program. The resulting promise of enhanced coverage in race detection has recently led to the development of many dynamic race prediction techniques.</fr:p><fr:p>In this tutorial we will discuss some of the state-of-the-art algorithms and techniques for dynamic data race prediction, present the foundations of race prediction in a principled manner and discuss some recent investigations on the complexity and hardness involved in reasoning about race prediction.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree>

  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>331</fr:anchor><fr:addr
type="machine">#248</fr:addr><fr:route>unstable-248.xml</fr:route><fr:title
text="Dissertations">Dissertations</fr:title><fr:authors><fr:author><fr:link
type="local"
href="daniellimws.xml"
addr="daniellimws"
title="Daniel Lim Wee Soong">Daniel Lim Wee Soong</fr:link></fr:author></fr:authors><fr:parent>dlws-0004</fr:parent></fr:frontmatter><fr:mainmatter><fr:p><fr:info>Query returned no results</fr:info></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>333</fr:anchor><fr:addr
type="machine">#249</fr:addr><fr:route>unstable-249.xml</fr:route><fr:title
text="People">People</fr:title><fr:authors><fr:author><fr:link
type="local"
href="daniellimws.xml"
addr="daniellimws"
title="Daniel Lim Wee Soong">Daniel Lim Wee Soong</fr:link></fr:author></fr:authors><fr:parent>dlws-0004</fr:parent></fr:frontmatter><fr:mainmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>335</fr:anchor><fr:addr
type="user">andreaspavlogiannis</fr:addr><fr:route>andreaspavlogiannis.xml</fr:route><fr:title
text="Andreas Pavlogiannis">Andreas Pavlogiannis</fr:title><fr:taxon>Person</fr:taxon><fr:authors /><fr:meta
name="external">https://pure.au.dk/portal/en/persons/pavlogiannis@cs.au.dk</fr:meta><fr:meta
name="institution"><fr:link
type="local"
href="aarhus.xml"
addr="aarhus"
title="Aarhus University">Aarhus University</fr:link></fr:meta><fr:meta
name="orcid">0000-0002-8943-0722</fr:meta><fr:meta
name="position">Associate Professor</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Associate Professor at Aarhus University.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>336</fr:anchor><fr:addr
type="user">azadehfarzan</fr:addr><fr:route>azadehfarzan.xml</fr:route><fr:title
text="Azadeh Farzan">Azadeh Farzan</fr:title><fr:taxon>Person</fr:taxon><fr:authors /><fr:meta
name="external">https://www.cs.toronto.edu/~azadeh/index.html</fr:meta><fr:meta
name="institution"><fr:link
type="local"
href="uoft.xml"
addr="uoft"
title="University of Toronto">University of Toronto</fr:link></fr:meta><fr:meta
name="orcid">0000-0001-9005-2653</fr:meta><fr:meta
name="position">Professor</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Professor at University of Toronto.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>337</fr:anchor><fr:addr
type="user">grigorerosu</fr:addr><fr:route>grigorerosu.xml</fr:route><fr:title
text="Grigore Rosu">Grigore Rosu</fr:title><fr:taxon>Person</fr:taxon><fr:authors /><fr:meta
name="external">https://fsl.cs.illinois.edu/people/grigore-rosu/</fr:meta><fr:meta
name="institution"><fr:link
type="local"
href="uiuc.xml"
addr="uiuc"
title="University of Illinois at Urbana-Champaign, USA">University of Illinois at Urbana-Champaign, USA</fr:link></fr:meta><fr:meta
name="orcid">0000-0002-3102-0421</fr:meta><fr:meta
name="position">Professor</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Professor of Computer Science at University of Illinois at Urbana-Champaign.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>338</fr:anchor><fr:addr
type="user">hünkarcantunç</fr:addr><fr:route>hünkarcantunç.xml</fr:route><fr:title
text="Hünkar Can Tunç">Hünkar Can Tunç</fr:title><fr:taxon>Person</fr:taxon><fr:authors /><fr:meta
name="institution"><fr:link
type="local"
href="aarhus.xml"
addr="aarhus"
title="Aarhus University">Aarhus University</fr:link></fr:meta><fr:meta
name="orcid">0000-0001-9125-8506</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>339</fr:anchor><fr:addr
type="user">maheshviswanathan</fr:addr><fr:route>maheshviswanathan.xml</fr:route><fr:title
text="Mahesh Viswanathan">Mahesh Viswanathan</fr:title><fr:taxon>Person</fr:taxon><fr:authors /><fr:meta
name="external">https://vmahesh.cs.illinois.edu/</fr:meta><fr:meta
name="institution"><fr:link
type="local"
href="uiuc.xml"
addr="uiuc"
title="University of Illinois at Urbana-Champaign, USA">University of Illinois at Urbana-Champaign, USA</fr:link></fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>340</fr:anchor><fr:addr
type="user">minjianzhang</fr:addr><fr:route>minjianzhang.xml</fr:route><fr:title
text="Minjian Zhang">Minjian Zhang</fr:title><fr:taxon>Person</fr:taxon><fr:authors /><fr:meta
name="institution"><fr:link
type="local"
href="uiuc.xml"
addr="uiuc"
title="University of Illinois at Urbana-Champaign, USA">University of Illinois at Urbana-Champaign, USA</fr:link></fr:meta><fr:meta
name="orcid">0000-0002-5017-2228</fr:meta><fr:meta
name="position">PhD</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>PhD student at University of Illinois at Urbana-Champaign, USA.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>341</fr:anchor><fr:addr
type="user">umangmathur</fr:addr><fr:route>umangmathur.xml</fr:route><fr:title
text="Umang Mathur">Umang Mathur</fr:title><fr:taxon>Person</fr:taxon><fr:authors /><fr:meta
name="external">https://www.comp.nus.edu.sg/~umathur/</fr:meta><fr:meta
name="institution"><fr:link
type="local"
href="nus.xml"
addr="nus"
title="National University of Singapore">National University of Singapore</fr:link></fr:meta><fr:meta
name="orcid">0000-0002-7610-0660</fr:meta><fr:meta
name="position">Assistant Professor</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Assistant Professor in Programming Languages &amp; Software Engineering at the National University of Singapore.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>342</fr:anchor><fr:addr
type="user">zhendongang</fr:addr><fr:route>zhendongang.xml</fr:route><fr:title
text="Zhendong Ang">Zhendong Ang</fr:title><fr:taxon>Person</fr:taxon><fr:authors /><fr:meta
name="external">https://ang9876.github.io/</fr:meta><fr:meta
name="institution"><fr:link
type="local"
href="nus.xml"
addr="nus"
title="National University of Singapore">National University of Singapore</fr:link></fr:meta><fr:meta
name="orcid">0009-0002-0214-3462</fr:meta><fr:meta
name="position">PhD</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>PhD student in Programming Languages &amp; Software Engineering at the National University of Singapore.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>343</fr:anchor><fr:addr
type="user">zhengshi</fr:addr><fr:route>zhengshi.xml</fr:route><fr:title
text="Zheng Shi">Zheng Shi</fr:title><fr:taxon>Person</fr:taxon><fr:authors /><fr:meta
name="external">https://www.comp.nus.edu.sg/~zs357/</fr:meta><fr:meta
name="institution"><fr:link
type="local"
href="nus.xml"
addr="nus"
title="National University of Singapore">National University of Singapore</fr:link></fr:meta><fr:meta
name="orcid">0000-0001-5021-7134</fr:meta><fr:meta
name="position">PhD</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>PhD student in Programming Languages &amp; Software Engineering at the National University of Singapore.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>